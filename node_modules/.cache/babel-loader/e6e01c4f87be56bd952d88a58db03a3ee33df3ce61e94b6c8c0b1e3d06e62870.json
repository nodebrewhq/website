{"ast":null,"code":"import _orderBy from \"lodash/orderBy\";\nimport _uniq from \"lodash/uniq\";\nimport _isObject from \"lodash/isObject\";\nimport _defaults from \"lodash/defaults\";\nimport React from \"react\";\nimport * as Collection from \"./collection\";\nimport * as Domain from \"./domain\";\nimport * as Helpers from \"./helpers\";\n/**\n * Returns the first argument it receives\n * @param value The value to return\n * @returns The value given\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * Returns the axis (x or y) of a particular axis component\n * @param {Object} props: the props object.\n * @param {Boolean} horizontal: true for horizontal charts\n * @returns {String} the dimension appropriate for the axis given its props\n */\nexport function getAxis(props) {\n  const {\n    dependentAxis\n  } = props;\n  return dependentAxis ? \"y\" : \"x\";\n}\n\n/**\n * Returns all axis components that pass a given predicate\n * @param {Array} childComponents: an array of children\n * @param {Function} predicate: a predicate function that will be called with each\n * @returns {Array} all axis components that pass the given predicate or []\n */\nexport function findAxisComponents(childComponents, predicate) {\n  const predicateFunction = predicate || identity;\n  const findAxes = children => {\n    return children.reduce((memo, child) => {\n      if (child.type && child.type.role === \"axis\" && predicateFunction(child)) {\n        return memo.concat(child);\n      } else if (child.props && child.props.children) {\n        return memo.concat(findAxes(React.Children.toArray(child.props.children)));\n      }\n      return memo;\n    }, []);\n  };\n  return findAxes(childComponents);\n}\n\n/**\n * Returns a single axis component of the desired axis type (x or y)\n * @param {Array} childComponents: an array of children\n * @param {String} axis: desired axis either \"x\" or \"y\".\n * @returns {ReactComponent} an axis component of the desired axis or undefined\n */\nexport function getAxisComponent(childComponents, axis) {\n  const matchesAxis = component => {\n    const type = component.type.getAxis(component.props);\n    return type === axis;\n  };\n  return findAxisComponents(childComponents, matchesAxis)[0];\n}\n\n/**\n * Returns all axis components of the desired axis type (x or y) along with any\n * parent components excluding VictoryChart\n * @param {Array} childComponents: an optional array of children.\n * @param {String} type: desired axis either \"dependent\" or \"independent\".\n * @returns {ReactComponent} an axis component of the desired type or undefined\n */\nexport function getAxisComponentsWithParent(childComponents, type) {\n  const matchesType = child => {\n    return type === \"dependent\" ? child.props.dependentAxis : !child.props.dependentAxis;\n  };\n  const findComponents = children => {\n    return children.reduce((memo, child) => {\n      if (child.type && child.type.role === \"axis\" && matchesType(child)) {\n        return memo.concat(child);\n      } else if (child.props && child.props.children) {\n        const childAxis = findComponents(React.Children.toArray(child.props.children));\n        return childAxis.length > 0 ? memo.concat(child) : memo;\n      }\n      return memo;\n    }, []);\n  };\n  return findComponents(childComponents);\n}\nexport function getOrigin(domain) {\n  const getSingleOrigin = d => {\n    const domainMin = Math.min(...d);\n    const domainMax = Math.max(...d);\n    return domainMax < 0 ? domainMax : Math.max(0, domainMin);\n  };\n  return {\n    x: Collection.containsDates(domain.x) ? new Date(Math.min(...domain.x)) : getSingleOrigin(domain.x),\n    y: Collection.containsDates(domain.y) ? new Date(Math.min(...domain.y)) : getSingleOrigin(domain.y)\n  };\n}\nexport function getOriginSign(origin, domain) {\n  const getSign = () => {\n    return origin <= 0 && Math.max(...domain) <= 0 ? \"negative\" : \"positive\";\n  };\n  return Collection.containsDates(domain) ? \"positive\" : getSign();\n}\n\n/**\n * @param {Object} props: axis component props\n * @returns {Boolean} true when the axis is vertical\n */\nexport function isVertical(props) {\n  const orientation = props.orientation || (props.dependentAxis ? \"left\" : \"bottom\");\n  const vertical = {\n    top: false,\n    bottom: false,\n    left: true,\n    right: true\n  };\n  return vertical[orientation];\n}\n\n/**\n * @param {Object} props: axis component props\n * @returns {Boolean} true when tickValues contain strings\n */\nexport function stringTicks(props) {\n  return props.tickValues !== undefined && Collection.containsStrings(props.tickValues);\n}\nfunction getDefaultTickFormat(props) {\n  const {\n    tickValues\n  } = props;\n  const axis = getAxis(props);\n  const stringMap = props.stringMap && props.stringMap[axis];\n  const fallbackFormat = tickValues && !Collection.containsDates(tickValues) ? x => x : undefined;\n  if (!stringMap) {\n    return stringTicks(props) ? (x, index) => tickValues[index] : fallbackFormat;\n  }\n  const invertedStringMap = stringMap && Helpers.invert(stringMap);\n  const tickValueArray = _orderBy(Object.values(stringMap), n => n);\n  const dataNames = tickValueArray.map(tick => invertedStringMap[tick]);\n  // string ticks should have one tick of padding at the beginning\n  const dataTicks = [\"\", ...dataNames, \"\"];\n  return x => dataTicks[x];\n}\nfunction getStringTicks(props) {\n  const axis = getAxis(props);\n  const stringMap = props.stringMap && props.stringMap[axis];\n  const categories = Array.isArray(props.categories) ? props.categories : props.categories && props.categories[axis];\n  const ticksFromCategories = categories && Collection.containsOnlyStrings(categories) ? categories.map(tick => stringMap[tick]) : undefined;\n  const ticksFromStringMap = stringMap && Object.values(stringMap);\n  return ticksFromCategories && ticksFromCategories.length !== 0 ? ticksFromCategories : ticksFromStringMap;\n}\nfunction getTickArray(props) {\n  const {\n    tickValues,\n    tickFormat\n  } = props;\n  if (tickValues?.length === 0) {\n    return [];\n  }\n  const axis = getAxis(props);\n  const stringMap = props.stringMap && props.stringMap[axis];\n  const getTicksFromFormat = () => {\n    if (!tickFormat || !Array.isArray(tickFormat)) {\n      return undefined;\n    }\n    return Collection.containsStrings(tickFormat) ? tickFormat.map((t, i) => i) : tickFormat;\n  };\n  let ticks = tickValues;\n  if (stringMap) {\n    ticks = getStringTicks(props);\n  }\n  if (tickValues && Collection.containsStrings(tickValues)) {\n    ticks = stringMap ? tickValues.map(tick => stringMap[tick]) : Helpers.range(1, tickValues.length + 1);\n  }\n  const tickArray = ticks ? _uniq(ticks) : getTicksFromFormat();\n  const buildTickArray = arr => {\n    const newTickArray = [];\n    const domain = props.domain && props.domain[axis] || props.domain;\n    if (arr) {\n      arr.forEach((t, index) => {\n        if (Array.isArray(domain)) {\n          if (t >= Collection.getMinValue(domain) && t <= Collection.getMaxValue(domain)) {\n            newTickArray.push({\n              value: t,\n              index\n            });\n          }\n        } else {\n          newTickArray.push({\n            value: t,\n            index\n          });\n        }\n      });\n      return newTickArray;\n    }\n    return undefined;\n  };\n  return Array.isArray(tickArray) && tickArray.length ? buildTickArray(tickArray) : undefined;\n}\nexport function getTickFormat(props, scale) {\n  const {\n    tickFormat\n  } = props;\n  const axis = getAxis(props);\n  const stringMap = props.stringMap && props.stringMap[axis];\n  if (!tickFormat) {\n    const defaultTickFormat = getDefaultTickFormat(props);\n    // If there is no user-provided tick format, we use d3's tickFormat function\n    // by default. This changed the default formatting for some scale types when\n    // we upgraded to d3-scale@4..\n    const scaleTickFormat = scale.tickFormat && Helpers.isFunction(scale.tickFormat) ? scale.tickFormat() : x => x;\n    return defaultTickFormat || scaleTickFormat;\n  } else if (tickFormat && Array.isArray(tickFormat)) {\n    const tickArray = getTickArray(props);\n    const tickArrayIndices = tickArray?.map(v => v.index);\n    const filteredTickFormat = tickFormat.filter((t, index) => tickArrayIndices?.includes(index));\n    return (x, index) => filteredTickFormat[index];\n  } else if (tickFormat && Helpers.isFunction(tickFormat)) {\n    const applyStringTicks = (tick, index, ticks) => {\n      const invertedStringMap = Helpers.invert(stringMap);\n      const stringTickArray = ticks.map(t => invertedStringMap[t]);\n      return props.tickFormat(invertedStringMap[tick], index, stringTickArray);\n    };\n    return stringMap ? applyStringTicks : tickFormat;\n  }\n  return x => x;\n}\nfunction downsampleTicks(ticks, tickCount) {\n  if (!tickCount || !Array.isArray(ticks) || ticks.length <= tickCount) {\n    return ticks;\n  }\n  const k = Math.floor(ticks.length / tickCount);\n  return ticks.filter((d, i) => i % k === 0);\n}\nexport function getTicks(props, scale, filterZero) {\n  if (filterZero === void 0) {\n    filterZero = false;\n  }\n  const {\n    tickCount\n  } = props;\n  const tickArray = getTickArray(props);\n  if (tickArray?.length === 0) {\n    return [\"\"];\n  }\n  const tickValues = tickArray ? tickArray.map(v => v.value) : undefined;\n  if (tickValues) {\n    return downsampleTicks(tickValues, tickCount);\n  } else if (scale.ticks && Helpers.isFunction(scale.ticks)) {\n    // eslint-disable-next-line no-magic-numbers\n    const defaultTickCount = tickCount || 5;\n    const scaleTicks = scale.ticks(defaultTickCount);\n    const scaledTickArray = Array.isArray(scaleTicks) && scaleTicks.length ? scaleTicks : scale.domain();\n    const ticks = downsampleTicks(scaledTickArray, tickCount);\n    if (filterZero) {\n      const filteredTicks = ticks.filter(value => value !== 0);\n      return filteredTicks.length ? filteredTicks : ticks;\n    }\n    return ticks;\n  }\n  return scale.domain();\n}\n\n/**\n * Returns a domain based tickValues\n * @param {Object} props: the props object\n * @param {String} axis: either x or y\n * @returns {Array} returns a domain from tickValues\n */\n// eslint-disable-next-line max-statements\nfunction getDomainFromData(props, axis) {\n  const {\n    polar,\n    startAngle = 0,\n    endAngle = 360\n  } = props;\n  const tickArray = getTickArray(props);\n  const tickValues = tickArray && tickArray?.length !== 0 ? tickArray.map(v => v.value) : undefined;\n  if (!Array.isArray(tickValues)) {\n    return undefined;\n  }\n  const minDomain = Domain.getMinFromProps(props, axis);\n  const maxDomain = Domain.getMaxFromProps(props, axis);\n  const tickStrings = stringTicks(props);\n  const ticks = tickValues.map(value => Number(value));\n  const defaultMin = tickStrings ? 1 : Collection.getMinValue(ticks);\n  const defaultMax = tickStrings ? tickValues.length : Collection.getMaxValue(ticks);\n  const min = minDomain !== undefined ? minDomain : defaultMin;\n  const max = maxDomain !== undefined ? maxDomain : defaultMax;\n  const initialDomain = Domain.getDomainFromMinMax(min, max);\n  const domain = polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? Domain.getSymmetricDomain(initialDomain, ticks) : initialDomain;\n  if (isVertical(props) && !polar) {\n    domain.reverse();\n  }\n  return domain;\n}\n\n// exposed for use by VictoryChart\nexport function getDomain(props, axis) {\n  const inherentAxis = getAxis(props);\n  if (axis && axis !== inherentAxis) {\n    return undefined;\n  }\n  return Domain.createDomainFunction(getDomainFromData)(props, inherentAxis);\n}\nexport function getAxisValue(props, axis) {\n  if (!props.axisValue) {\n    return undefined;\n  }\n  const scaleAxis = axis === \"x\" ? \"y\" : \"x\";\n  const scale = _isObject(props.scale) && Helpers.isFunction(props.scale[scaleAxis]) ? props.scale[scaleAxis] : undefined;\n  if (!scale) {\n    return undefined;\n  }\n  const stringMapAxis = axis === \"x\" ? \"y\" : \"x\";\n  const stringMap = _isObject(props.stringMap) && props.stringMap[stringMapAxis];\n  const axisValue = stringMap && typeof props.axisValue === \"string\" ? stringMap[props.axisValue] : props.axisValue;\n  return scale(axisValue);\n}\nexport function modifyProps(props, fallbackProps) {\n  if (!_isObject(props.theme)) {\n    return Helpers.modifyProps(props, fallbackProps, \"axis\");\n  }\n  let role = \"axis\";\n  if (props.dependentAxis && props.theme.dependentAxis) {\n    role = \"dependentAxis\";\n  } else if (!props.dependentAxis && props.theme.independentAxis) {\n    role = \"independentAxis\";\n  }\n  if (role === \"axis\") {\n    return Helpers.modifyProps(props, fallbackProps, \"axis\");\n  }\n  const axisTheme = _defaults({}, props.theme[role], props.theme.axis);\n  const theme = Object.assign({}, props.theme, {\n    axis: axisTheme\n  });\n  return Helpers.modifyProps(Object.assign({}, props, {\n    theme\n  }), fallbackProps, \"axis\");\n}","map":{"version":3,"names":["_orderBy","_uniq","_isObject","_defaults","React","Collection","Domain","Helpers","identity","value","getAxis","props","dependentAxis","findAxisComponents","childComponents","predicate","predicateFunction","findAxes","children","reduce","memo","child","type","role","concat","Children","toArray","getAxisComponent","axis","matchesAxis","component","getAxisComponentsWithParent","matchesType","findComponents","childAxis","length","getOrigin","domain","getSingleOrigin","d","domainMin","Math","min","domainMax","max","x","containsDates","Date","y","getOriginSign","origin","getSign","isVertical","orientation","vertical","top","bottom","left","right","stringTicks","tickValues","undefined","containsStrings","getDefaultTickFormat","stringMap","fallbackFormat","index","invertedStringMap","invert","tickValueArray","Object","values","n","dataNames","map","tick","dataTicks","getStringTicks","categories","Array","isArray","ticksFromCategories","containsOnlyStrings","ticksFromStringMap","getTickArray","tickFormat","getTicksFromFormat","t","i","ticks","range","tickArray","buildTickArray","arr","newTickArray","forEach","getMinValue","getMaxValue","push","getTickFormat","scale","defaultTickFormat","scaleTickFormat","isFunction","tickArrayIndices","v","filteredTickFormat","filter","includes","applyStringTicks","stringTickArray","downsampleTicks","tickCount","k","floor","getTicks","filterZero","defaultTickCount","scaleTicks","scaledTickArray","filteredTicks","getDomainFromData","polar","startAngle","endAngle","minDomain","getMinFromProps","maxDomain","getMaxFromProps","tickStrings","Number","defaultMin","defaultMax","initialDomain","getDomainFromMinMax","abs","getSymmetricDomain","reverse","getDomain","inherentAxis","createDomainFunction","getAxisValue","axisValue","scaleAxis","stringMapAxis","modifyProps","fallbackProps","theme","independentAxis","axisTheme","assign"],"sources":["/Users/anjalichaturvedi/GitHub/brew-bridge-dashboard/website/node_modules/victory-core/es/victory-util/axis.js"],"sourcesContent":["import _orderBy from \"lodash/orderBy\";\nimport _uniq from \"lodash/uniq\";\nimport _isObject from \"lodash/isObject\";\nimport _defaults from \"lodash/defaults\";\nimport React from \"react\";\nimport * as Collection from \"./collection\";\nimport * as Domain from \"./domain\";\nimport * as Helpers from \"./helpers\";\n/**\n * Returns the first argument it receives\n * @param value The value to return\n * @returns The value given\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * Returns the axis (x or y) of a particular axis component\n * @param {Object} props: the props object.\n * @param {Boolean} horizontal: true for horizontal charts\n * @returns {String} the dimension appropriate for the axis given its props\n */\nexport function getAxis(props) {\n  const {\n    dependentAxis\n  } = props;\n  return dependentAxis ? \"y\" : \"x\";\n}\n\n/**\n * Returns all axis components that pass a given predicate\n * @param {Array} childComponents: an array of children\n * @param {Function} predicate: a predicate function that will be called with each\n * @returns {Array} all axis components that pass the given predicate or []\n */\nexport function findAxisComponents(childComponents, predicate) {\n  const predicateFunction = predicate || identity;\n  const findAxes = children => {\n    return children.reduce((memo, child) => {\n      if (child.type && child.type.role === \"axis\" && predicateFunction(child)) {\n        return memo.concat(child);\n      } else if (child.props && child.props.children) {\n        return memo.concat(findAxes(React.Children.toArray(child.props.children)));\n      }\n      return memo;\n    }, []);\n  };\n  return findAxes(childComponents);\n}\n\n/**\n * Returns a single axis component of the desired axis type (x or y)\n * @param {Array} childComponents: an array of children\n * @param {String} axis: desired axis either \"x\" or \"y\".\n * @returns {ReactComponent} an axis component of the desired axis or undefined\n */\nexport function getAxisComponent(childComponents, axis) {\n  const matchesAxis = component => {\n    const type = component.type.getAxis(component.props);\n    return type === axis;\n  };\n  return findAxisComponents(childComponents, matchesAxis)[0];\n}\n\n/**\n * Returns all axis components of the desired axis type (x or y) along with any\n * parent components excluding VictoryChart\n * @param {Array} childComponents: an optional array of children.\n * @param {String} type: desired axis either \"dependent\" or \"independent\".\n * @returns {ReactComponent} an axis component of the desired type or undefined\n */\nexport function getAxisComponentsWithParent(childComponents, type) {\n  const matchesType = child => {\n    return type === \"dependent\" ? child.props.dependentAxis : !child.props.dependentAxis;\n  };\n  const findComponents = children => {\n    return children.reduce((memo, child) => {\n      if (child.type && child.type.role === \"axis\" && matchesType(child)) {\n        return memo.concat(child);\n      } else if (child.props && child.props.children) {\n        const childAxis = findComponents(React.Children.toArray(child.props.children));\n        return childAxis.length > 0 ? memo.concat(child) : memo;\n      }\n      return memo;\n    }, []);\n  };\n  return findComponents(childComponents);\n}\nexport function getOrigin(domain) {\n  const getSingleOrigin = d => {\n    const domainMin = Math.min(...d);\n    const domainMax = Math.max(...d);\n    return domainMax < 0 ? domainMax : Math.max(0, domainMin);\n  };\n  return {\n    x: Collection.containsDates(domain.x) ? new Date(Math.min(...domain.x)) : getSingleOrigin(domain.x),\n    y: Collection.containsDates(domain.y) ? new Date(Math.min(...domain.y)) : getSingleOrigin(domain.y)\n  };\n}\nexport function getOriginSign(origin, domain) {\n  const getSign = () => {\n    return origin <= 0 && Math.max(...domain) <= 0 ? \"negative\" : \"positive\";\n  };\n  return Collection.containsDates(domain) ? \"positive\" : getSign();\n}\n\n/**\n * @param {Object} props: axis component props\n * @returns {Boolean} true when the axis is vertical\n */\nexport function isVertical(props) {\n  const orientation = props.orientation || (props.dependentAxis ? \"left\" : \"bottom\");\n  const vertical = {\n    top: false,\n    bottom: false,\n    left: true,\n    right: true\n  };\n  return vertical[orientation];\n}\n\n/**\n * @param {Object} props: axis component props\n * @returns {Boolean} true when tickValues contain strings\n */\nexport function stringTicks(props) {\n  return props.tickValues !== undefined && Collection.containsStrings(props.tickValues);\n}\nfunction getDefaultTickFormat(props) {\n  const {\n    tickValues\n  } = props;\n  const axis = getAxis(props);\n  const stringMap = props.stringMap && props.stringMap[axis];\n  const fallbackFormat = tickValues && !Collection.containsDates(tickValues) ? x => x : undefined;\n  if (!stringMap) {\n    return stringTicks(props) ? (x, index) => tickValues[index] : fallbackFormat;\n  }\n  const invertedStringMap = stringMap && Helpers.invert(stringMap);\n  const tickValueArray = _orderBy(Object.values(stringMap), n => n);\n  const dataNames = tickValueArray.map(tick => invertedStringMap[tick]);\n  // string ticks should have one tick of padding at the beginning\n  const dataTicks = [\"\", ...dataNames, \"\"];\n  return x => dataTicks[x];\n}\nfunction getStringTicks(props) {\n  const axis = getAxis(props);\n  const stringMap = props.stringMap && props.stringMap[axis];\n  const categories = Array.isArray(props.categories) ? props.categories : props.categories && props.categories[axis];\n  const ticksFromCategories = categories && Collection.containsOnlyStrings(categories) ? categories.map(tick => stringMap[tick]) : undefined;\n  const ticksFromStringMap = stringMap && Object.values(stringMap);\n  return ticksFromCategories && ticksFromCategories.length !== 0 ? ticksFromCategories : ticksFromStringMap;\n}\nfunction getTickArray(props) {\n  const {\n    tickValues,\n    tickFormat\n  } = props;\n  if (tickValues?.length === 0) {\n    return [];\n  }\n  const axis = getAxis(props);\n  const stringMap = props.stringMap && props.stringMap[axis];\n  const getTicksFromFormat = () => {\n    if (!tickFormat || !Array.isArray(tickFormat)) {\n      return undefined;\n    }\n    return Collection.containsStrings(tickFormat) ? tickFormat.map((t, i) => i) : tickFormat;\n  };\n  let ticks = tickValues;\n  if (stringMap) {\n    ticks = getStringTicks(props);\n  }\n  if (tickValues && Collection.containsStrings(tickValues)) {\n    ticks = stringMap ? tickValues.map(tick => stringMap[tick]) : Helpers.range(1, tickValues.length + 1);\n  }\n  const tickArray = ticks ? _uniq(ticks) : getTicksFromFormat();\n  const buildTickArray = arr => {\n    const newTickArray = [];\n    const domain = props.domain && props.domain[axis] || props.domain;\n    if (arr) {\n      arr.forEach((t, index) => {\n        if (Array.isArray(domain)) {\n          if (t >= Collection.getMinValue(domain) && t <= Collection.getMaxValue(domain)) {\n            newTickArray.push({\n              value: t,\n              index\n            });\n          }\n        } else {\n          newTickArray.push({\n            value: t,\n            index\n          });\n        }\n      });\n      return newTickArray;\n    }\n    return undefined;\n  };\n  return Array.isArray(tickArray) && tickArray.length ? buildTickArray(tickArray) : undefined;\n}\nexport function getTickFormat(props, scale) {\n  const {\n    tickFormat\n  } = props;\n  const axis = getAxis(props);\n  const stringMap = props.stringMap && props.stringMap[axis];\n  if (!tickFormat) {\n    const defaultTickFormat = getDefaultTickFormat(props);\n    // If there is no user-provided tick format, we use d3's tickFormat function\n    // by default. This changed the default formatting for some scale types when\n    // we upgraded to d3-scale@4..\n    const scaleTickFormat = scale.tickFormat && Helpers.isFunction(scale.tickFormat) ? scale.tickFormat() : x => x;\n    return defaultTickFormat || scaleTickFormat;\n  } else if (tickFormat && Array.isArray(tickFormat)) {\n    const tickArray = getTickArray(props);\n    const tickArrayIndices = tickArray?.map(v => v.index);\n    const filteredTickFormat = tickFormat.filter((t, index) => tickArrayIndices?.includes(index));\n    return (x, index) => filteredTickFormat[index];\n  } else if (tickFormat && Helpers.isFunction(tickFormat)) {\n    const applyStringTicks = (tick, index, ticks) => {\n      const invertedStringMap = Helpers.invert(stringMap);\n      const stringTickArray = ticks.map(t => invertedStringMap[t]);\n      return props.tickFormat(invertedStringMap[tick], index, stringTickArray);\n    };\n    return stringMap ? applyStringTicks : tickFormat;\n  }\n  return x => x;\n}\nfunction downsampleTicks(ticks, tickCount) {\n  if (!tickCount || !Array.isArray(ticks) || ticks.length <= tickCount) {\n    return ticks;\n  }\n  const k = Math.floor(ticks.length / tickCount);\n  return ticks.filter((d, i) => i % k === 0);\n}\nexport function getTicks(props, scale, filterZero) {\n  if (filterZero === void 0) {\n    filterZero = false;\n  }\n  const {\n    tickCount\n  } = props;\n  const tickArray = getTickArray(props);\n  if (tickArray?.length === 0) {\n    return [\"\"];\n  }\n  const tickValues = tickArray ? tickArray.map(v => v.value) : undefined;\n  if (tickValues) {\n    return downsampleTicks(tickValues, tickCount);\n  } else if (scale.ticks && Helpers.isFunction(scale.ticks)) {\n    // eslint-disable-next-line no-magic-numbers\n    const defaultTickCount = tickCount || 5;\n    const scaleTicks = scale.ticks(defaultTickCount);\n    const scaledTickArray = Array.isArray(scaleTicks) && scaleTicks.length ? scaleTicks : scale.domain();\n    const ticks = downsampleTicks(scaledTickArray, tickCount);\n    if (filterZero) {\n      const filteredTicks = ticks.filter(value => value !== 0);\n      return filteredTicks.length ? filteredTicks : ticks;\n    }\n    return ticks;\n  }\n  return scale.domain();\n}\n\n/**\n * Returns a domain based tickValues\n * @param {Object} props: the props object\n * @param {String} axis: either x or y\n * @returns {Array} returns a domain from tickValues\n */\n// eslint-disable-next-line max-statements\nfunction getDomainFromData(props, axis) {\n  const {\n    polar,\n    startAngle = 0,\n    endAngle = 360\n  } = props;\n  const tickArray = getTickArray(props);\n  const tickValues = tickArray && tickArray?.length !== 0 ? tickArray.map(v => v.value) : undefined;\n  if (!Array.isArray(tickValues)) {\n    return undefined;\n  }\n  const minDomain = Domain.getMinFromProps(props, axis);\n  const maxDomain = Domain.getMaxFromProps(props, axis);\n  const tickStrings = stringTicks(props);\n  const ticks = tickValues.map(value => Number(value));\n  const defaultMin = tickStrings ? 1 : Collection.getMinValue(ticks);\n  const defaultMax = tickStrings ? tickValues.length : Collection.getMaxValue(ticks);\n  const min = minDomain !== undefined ? minDomain : defaultMin;\n  const max = maxDomain !== undefined ? maxDomain : defaultMax;\n  const initialDomain = Domain.getDomainFromMinMax(min, max);\n  const domain = polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? Domain.getSymmetricDomain(initialDomain, ticks) : initialDomain;\n  if (isVertical(props) && !polar) {\n    domain.reverse();\n  }\n  return domain;\n}\n\n// exposed for use by VictoryChart\nexport function getDomain(props, axis) {\n  const inherentAxis = getAxis(props);\n  if (axis && axis !== inherentAxis) {\n    return undefined;\n  }\n  return Domain.createDomainFunction(getDomainFromData)(props, inherentAxis);\n}\nexport function getAxisValue(props, axis) {\n  if (!props.axisValue) {\n    return undefined;\n  }\n  const scaleAxis = axis === \"x\" ? \"y\" : \"x\";\n  const scale = _isObject(props.scale) && Helpers.isFunction(props.scale[scaleAxis]) ? props.scale[scaleAxis] : undefined;\n  if (!scale) {\n    return undefined;\n  }\n  const stringMapAxis = axis === \"x\" ? \"y\" : \"x\";\n  const stringMap = _isObject(props.stringMap) && props.stringMap[stringMapAxis];\n  const axisValue = stringMap && typeof props.axisValue === \"string\" ? stringMap[props.axisValue] : props.axisValue;\n  return scale(axisValue);\n}\nexport function modifyProps(props, fallbackProps) {\n  if (!_isObject(props.theme)) {\n    return Helpers.modifyProps(props, fallbackProps, \"axis\");\n  }\n  let role = \"axis\";\n  if (props.dependentAxis && props.theme.dependentAxis) {\n    role = \"dependentAxis\";\n  } else if (!props.dependentAxis && props.theme.independentAxis) {\n    role = \"independentAxis\";\n  }\n  if (role === \"axis\") {\n    return Helpers.modifyProps(props, fallbackProps, \"axis\");\n  }\n  const axisTheme = _defaults({}, props.theme[role], props.theme.axis);\n  const theme = Object.assign({}, props.theme, {\n    axis: axisTheme\n  });\n  return Helpers.modifyProps(Object.assign({}, props, {\n    theme\n  }), fallbackProps, \"axis\");\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
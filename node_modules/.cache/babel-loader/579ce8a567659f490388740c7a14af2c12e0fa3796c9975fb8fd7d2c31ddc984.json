{"ast":null,"code":"import _isPlainObject from \"lodash/isPlainObject\";\n/* eslint-disable no-use-before-define */\nimport * as Helpers from \"./helpers\";\nimport * as Collection from \"./collection\";\nimport * as d3Scale from \"victory-vendor/d3-scale\";\nconst supportedScaleStrings = [\"linear\", \"time\", \"log\", \"sqrt\"];\n// Private Functions\n\nfunction toNewName(scale) {\n  // d3 scale changed the naming scheme for scale from \"linear\" -> \"scaleLinear\" etc.\n  const capitalize = s => s && s[0].toUpperCase() + s.slice(1);\n  return `scale${capitalize(scale)}`;\n}\nexport function validScale(scale) {\n  if (typeof scale === \"function\") {\n    return Helpers.isFunction(scale.copy) && Helpers.isFunction(scale.domain) && Helpers.isFunction(scale.range);\n  } else if (typeof scale === \"string\") {\n    return supportedScaleStrings.includes(scale);\n  }\n  return false;\n}\nfunction isScaleDefined(props, axis) {\n  if (!props.scale) {\n    return false;\n  } else if (props.scale.x || props.scale.y) {\n    return !!props.scale[axis];\n  }\n  return true;\n}\nfunction getScaleTypeFromProps(props, axis) {\n  if (!isScaleDefined(props, axis)) {\n    return undefined;\n  }\n  const scale = props.scale[axis] || props.scale;\n  return typeof scale === \"string\" ? scale : getType(scale);\n}\nfunction getScaleFromDomain(props, axis) {\n  let domain;\n  if (props.domain && props.domain[axis]) {\n    domain = props.domain[axis];\n  } else if (props.domain && Array.isArray(props.domain)) {\n    domain = props.domain;\n  }\n  if (!domain) {\n    return undefined;\n  }\n  return Collection.containsDates(domain) ? \"time\" : \"linear\";\n}\nfunction getScaleTypeFromData(props, axis) {\n  if (!props.data) {\n    return \"linear\";\n  }\n  const accessor = Helpers.createAccessor(props[axis]);\n  const axisData = props.data.map(datum => {\n    const processedData = _isPlainObject(accessor(datum)) ? accessor(datum)[axis] : accessor(datum);\n    return processedData !== undefined ? processedData : datum[axis];\n  });\n  return Collection.containsDates(axisData) ? \"time\" : \"linear\";\n}\n\n// Exported Functions\n\nexport function getScaleFromName(name) {\n  if (validScale(name)) {\n    const methodName = toNewName(name);\n    // @ts-expect-error scaleTime is not directly compatible with our D3Scale definition\n    return d3Scale[methodName]();\n  }\n  return d3Scale.scaleLinear();\n}\nexport function getBaseScale(props, axis) {\n  const scale = getScaleFromProps(props, axis);\n  if (scale) {\n    return typeof scale === \"string\" ? getScaleFromName(scale) : scale;\n  }\n  const defaultScale = getScaleFromDomain(props, axis) || getScaleTypeFromData(props, axis);\n  return getScaleFromName(defaultScale);\n}\nexport function getDefaultScale() {\n  return d3Scale.scaleLinear();\n}\nexport function getScaleFromProps(props, axis) {\n  if (!isScaleDefined(props, axis)) {\n    return undefined;\n  }\n  const scale = props.scale[axis] || props.scale;\n  if (validScale(scale)) {\n    return Helpers.isFunction(scale) ? scale : getScaleFromName(scale);\n  }\n  return undefined;\n}\nexport function getScaleType(props, axis) {\n  // if the scale was not given in props, it will be set to linear or time depending on data\n  return getScaleTypeFromProps(props, axis) || getScaleTypeFromData(props, axis);\n}\n\n// Ordered type inference off of function fields.\n// **Note**: Brittle because reliant on d3 internals.\nconst DUCK_TYPES = [{\n  name: \"quantile\",\n  method: \"quantiles\"\n}, {\n  name: \"log\",\n  method: \"base\"\n}\n// TODO(2214): Re-evaluate (1) duck typing approach, and (2) if duck typing,\n//   do we need a different approach? (Multiple keys? Stringifying functions?)\n// https://github.com/FormidableLabs/victory/issues/2214\n// Below are matches that don't seem to otherwise occur in Victory code base.\n// { name: \"ordinal\", method: \"unknown\" },\n// { name: \"pow-sqrt\", method: \"exponent\" },\n// { name: \"quantize-threshold\", method: \"invertExtent\" }\n];\nexport function getType(scale) {\n  if (typeof scale === \"string\") {\n    return scale;\n  }\n  const scaleType = DUCK_TYPES.filter(type => {\n    return scale[type.method] !== undefined;\n  })[0];\n  return scaleType ? scaleType.name : undefined;\n}","map":{"version":3,"names":["_isPlainObject","Helpers","Collection","d3Scale","supportedScaleStrings","toNewName","scale","capitalize","s","toUpperCase","slice","validScale","isFunction","copy","domain","range","includes","isScaleDefined","props","axis","x","y","getScaleTypeFromProps","undefined","getType","getScaleFromDomain","Array","isArray","containsDates","getScaleTypeFromData","data","accessor","createAccessor","axisData","map","datum","processedData","getScaleFromName","name","methodName","scaleLinear","getBaseScale","getScaleFromProps","defaultScale","getDefaultScale","getScaleType","DUCK_TYPES","method","scaleType","filter","type"],"sources":["/Users/anjalichaturvedi/GitHub/brew-bridge-dashboard/website/node_modules/victory-core/es/victory-util/scale.js"],"sourcesContent":["import _isPlainObject from \"lodash/isPlainObject\";\n/* eslint-disable no-use-before-define */\nimport * as Helpers from \"./helpers\";\nimport * as Collection from \"./collection\";\nimport * as d3Scale from \"victory-vendor/d3-scale\";\nconst supportedScaleStrings = [\"linear\", \"time\", \"log\", \"sqrt\"];\n// Private Functions\n\nfunction toNewName(scale) {\n  // d3 scale changed the naming scheme for scale from \"linear\" -> \"scaleLinear\" etc.\n  const capitalize = s => s && s[0].toUpperCase() + s.slice(1);\n  return `scale${capitalize(scale)}`;\n}\nexport function validScale(scale) {\n  if (typeof scale === \"function\") {\n    return Helpers.isFunction(scale.copy) && Helpers.isFunction(scale.domain) && Helpers.isFunction(scale.range);\n  } else if (typeof scale === \"string\") {\n    return supportedScaleStrings.includes(scale);\n  }\n  return false;\n}\nfunction isScaleDefined(props, axis) {\n  if (!props.scale) {\n    return false;\n  } else if (props.scale.x || props.scale.y) {\n    return !!props.scale[axis];\n  }\n  return true;\n}\nfunction getScaleTypeFromProps(props, axis) {\n  if (!isScaleDefined(props, axis)) {\n    return undefined;\n  }\n  const scale = props.scale[axis] || props.scale;\n  return typeof scale === \"string\" ? scale : getType(scale);\n}\nfunction getScaleFromDomain(props, axis) {\n  let domain;\n  if (props.domain && props.domain[axis]) {\n    domain = props.domain[axis];\n  } else if (props.domain && Array.isArray(props.domain)) {\n    domain = props.domain;\n  }\n  if (!domain) {\n    return undefined;\n  }\n  return Collection.containsDates(domain) ? \"time\" : \"linear\";\n}\nfunction getScaleTypeFromData(props, axis) {\n  if (!props.data) {\n    return \"linear\";\n  }\n  const accessor = Helpers.createAccessor(props[axis]);\n  const axisData = props.data.map(datum => {\n    const processedData = _isPlainObject(accessor(datum)) ? accessor(datum)[axis] : accessor(datum);\n    return processedData !== undefined ? processedData : datum[axis];\n  });\n  return Collection.containsDates(axisData) ? \"time\" : \"linear\";\n}\n\n// Exported Functions\n\nexport function getScaleFromName(name) {\n  if (validScale(name)) {\n    const methodName = toNewName(name);\n    // @ts-expect-error scaleTime is not directly compatible with our D3Scale definition\n    return d3Scale[methodName]();\n  }\n  return d3Scale.scaleLinear();\n}\nexport function getBaseScale(props, axis) {\n  const scale = getScaleFromProps(props, axis);\n  if (scale) {\n    return typeof scale === \"string\" ? getScaleFromName(scale) : scale;\n  }\n  const defaultScale = getScaleFromDomain(props, axis) || getScaleTypeFromData(props, axis);\n  return getScaleFromName(defaultScale);\n}\nexport function getDefaultScale() {\n  return d3Scale.scaleLinear();\n}\nexport function getScaleFromProps(props, axis) {\n  if (!isScaleDefined(props, axis)) {\n    return undefined;\n  }\n  const scale = props.scale[axis] || props.scale;\n  if (validScale(scale)) {\n    return Helpers.isFunction(scale) ? scale : getScaleFromName(scale);\n  }\n  return undefined;\n}\nexport function getScaleType(props, axis) {\n  // if the scale was not given in props, it will be set to linear or time depending on data\n  return getScaleTypeFromProps(props, axis) || getScaleTypeFromData(props, axis);\n}\n\n// Ordered type inference off of function fields.\n// **Note**: Brittle because reliant on d3 internals.\nconst DUCK_TYPES = [{\n  name: \"quantile\",\n  method: \"quantiles\"\n}, {\n  name: \"log\",\n  method: \"base\"\n}\n// TODO(2214): Re-evaluate (1) duck typing approach, and (2) if duck typing,\n//   do we need a different approach? (Multiple keys? Stringifying functions?)\n// https://github.com/FormidableLabs/victory/issues/2214\n// Below are matches that don't seem to otherwise occur in Victory code base.\n// { name: \"ordinal\", method: \"unknown\" },\n// { name: \"pow-sqrt\", method: \"exponent\" },\n// { name: \"quantize-threshold\", method: \"invertExtent\" }\n];\nexport function getType(scale) {\n  if (typeof scale === \"string\") {\n    return scale;\n  }\n  const scaleType = DUCK_TYPES.filter(type => {\n    return scale[type.method] !== undefined;\n  })[0];\n  return scaleType ? scaleType.name : undefined;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
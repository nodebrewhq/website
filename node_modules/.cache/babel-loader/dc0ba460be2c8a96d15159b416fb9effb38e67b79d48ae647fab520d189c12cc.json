{"ast":null,"code":"import _uniq from \"lodash/uniq\";\nimport _omitBy from \"lodash/omitBy\";\nimport _pickBy from \"lodash/pickBy\";\nimport _isEmpty from \"lodash/isEmpty\";\n/* eslint-disable no-use-before-define */\nimport { isFunction } from \"./helpers\";\nconst GLOBAL_EVENT_REGEX = /^onGlobal(.*)$/;\n\n// Normally we'd use Template Literal Types, but we're avoiding it to maximize TS compatibility with TS < 4.1\n// `on${Capitalize<string>}`;\n\n/* Returns all own and shared events that should be attached to a single target element,\n * i.e. an individual bar specified by target: \"data\", eventKey: [index].\n * Returned events are scoped to the appropriate state. Either that of the component itself\n * (i.e. VictoryBar) in the case of own events, or that of the parent component\n * (i.e. VictoryChart) in the case of shared events\n */\n// eslint-disable-next-line max-params\nexport function getEvents(props, target, eventKey,\n// eslint-disable-next-line no-shadow\ngetScopedEvents) {\n  // Returns all events that apply to a particular target element\n  const getEventsByTarget = events => {\n    const getSelectedEvents = () => {\n      const targetEvents = events.reduce((memo, event) => {\n        if (event.target !== undefined) {\n          const matchesTarget = Array.isArray(event.target) ? event.target.includes(target) : `${event.target}` === `${target}`;\n          return matchesTarget ? memo.concat(event) : memo;\n        }\n        return memo.concat(event);\n      }, []);\n      if (eventKey !== undefined && target !== \"parent\") {\n        return targetEvents.filter(obj => {\n          const targetKeys = obj.eventKey;\n          const useKey = key => key ? `${key}` === `${eventKey}` : true;\n          return Array.isArray(targetKeys) ? targetKeys.some(k => useKey(k)) : useKey(targetKeys);\n        });\n      }\n      return targetEvents;\n    };\n    const selectedEvents = getSelectedEvents();\n    return Array.isArray(selectedEvents) && selectedEvents.reduce((memo, event) => {\n      return event ? Object.assign(memo, event.eventHandlers) : memo;\n    }, {});\n  };\n\n  /* Returns all events from props and defaultEvents from components. Events handlers\n   * specified in props will override handlers for the same event if they are also\n   * specified in defaultEvents of a sub-component\n   */\n  const getAllEvents = () => {\n    // Mandatory usage: `getEvents.bind(this)`\n    /* eslint-disable no-invalid-this */\n    if (Array.isArray(this.componentEvents)) {\n      return Array.isArray(props.events) ? this.componentEvents.concat(...props.events) : this.componentEvents;\n    }\n    /* eslint-enable no-invalid-this */\n    return props.events;\n  };\n  const allEvents = getAllEvents();\n  const ownEvents = allEvents && isFunction(getScopedEvents) ? getScopedEvents(getEventsByTarget(allEvents), target) : undefined;\n  if (!props.sharedEvents) {\n    return ownEvents;\n  }\n  const getSharedEvents = props.sharedEvents.getEvents;\n  const sharedEvents = props.sharedEvents.events && getSharedEvents(getEventsByTarget(props.sharedEvents.events), target);\n  return Object.assign({}, sharedEvents, ownEvents);\n}\n\n/* Returns a modified events object where each event handler is replaced by a new\n * function that calls the original handler and then calls setState with the return\n * of the original event handler assigned to state property that maps to the target\n * element.\n */\n// eslint-disable-next-line max-params\nexport function getScopedEvents(events, namespace, childType, baseProps) {\n  if (_isEmpty(events)) {\n    return {};\n  }\n\n  // Mandatory usage: `getScopedEvents.bind(this)`\n  // eslint-disable-next-line no-invalid-this\n  const newBaseProps = baseProps || this.baseProps;\n  // returns the original base props or base state of a given target element\n  const getTargetProps = (identifier, type) => {\n    const {\n      childName,\n      target,\n      key\n    } = identifier;\n    // eslint-disable-next-line no-invalid-this\n    const baseType = type === \"props\" ? newBaseProps : this.state || {};\n    const base = childName === undefined || childName === null || !baseType[childName] ? baseType : baseType[childName];\n    return key === \"parent\" ? base.parent : base[key] && base[key][target];\n  };\n\n  // Returns the state object with the mutation caused by a given eventReturn\n  // applied to the appropriate property on the state object\n  const parseEvent = (eventReturn, eventKey) => {\n    const childNames = namespace === \"parent\" ? eventReturn.childName : eventReturn.childName || childType;\n    const target = eventReturn.target || namespace;\n\n    // returns all eventKeys to modify for a targeted childName\n    const getKeys = childName => {\n      if (target === \"parent\") {\n        return \"parent\";\n      }\n      if (eventReturn.eventKey === \"all\") {\n        return newBaseProps[childName] ? Object.keys(newBaseProps[childName]).filter(value => value !== \"parent\") : Object.keys(newBaseProps).filter(value => value !== \"parent\");\n      } else if (eventReturn.eventKey === undefined && eventKey === \"parent\") {\n        return newBaseProps[childName] ? Object.keys(newBaseProps[childName]) : Object.keys(newBaseProps);\n      }\n      return eventReturn.eventKey !== undefined ? eventReturn.eventKey : eventKey;\n    };\n\n    // returns the state object with mutated props applied for a single key\n    const getMutationObject = (key, childName) => {\n      // eslint-disable-next-line no-invalid-this\n      const baseState = this.state || {};\n      if (!isFunction(eventReturn.mutation)) {\n        return baseState;\n      }\n      const mutationTargetProps = getTargetProps({\n        childName,\n        key,\n        target\n      }, \"props\");\n      const mutationTargetState = getTargetProps({\n        childName,\n        key,\n        target\n      }, \"state\");\n      const mutatedProps = eventReturn.mutation(Object.assign({}, mutationTargetProps, mutationTargetState), newBaseProps);\n      const childState = baseState[childName] || {};\n      const filterState = state => {\n        if (state[key] && state[key][target]) {\n          delete state[key][target];\n        }\n        if (state[key] && !Object.keys(state[key]).length) {\n          delete state[key];\n        }\n        return state;\n      };\n      const extendState = state => {\n        return target === \"parent\" ? Object.assign(state, {\n          [key]: Object.assign(state[key] || {}, mutatedProps)\n        }) : Object.assign(state, {\n          [key]: Object.assign(state[key] || {}, {\n            [target]: mutatedProps\n          })\n        });\n      };\n      const updateState = state => {\n        return mutatedProps ? extendState(state) : filterState(state);\n      };\n      return childName !== undefined && childName !== null ? Object.assign(baseState, {\n        [childName]: updateState(childState)\n      }) : updateState(baseState);\n    };\n\n    // returns entire mutated state for a given childName\n    const getReturnByChild = childName => {\n      const mutationKeys = getKeys(childName);\n      return Array.isArray(mutationKeys) ? mutationKeys.reduce((memo, key) => {\n        return Object.assign(memo, getMutationObject(key, childName));\n      }, {}) : getMutationObject(mutationKeys, childName);\n    };\n\n    // returns an entire mutated state for all children\n    const allChildNames = childNames === \"all\" ? Object.keys(newBaseProps).filter(value => value !== \"parent\") : childNames;\n    return Array.isArray(allChildNames) ? allChildNames.reduce((memo, childName) => {\n      return Object.assign(memo, getReturnByChild(childName));\n    }, {}) : getReturnByChild(allChildNames);\n  };\n\n  // Parses an array of event returns into a single state mutation\n  const parseEventReturn = (eventReturn, eventKey) => {\n    return Array.isArray(eventReturn) ? eventReturn.reduce((memo, props) => Object.assign({}, memo, parseEvent(props, eventKey)), {}) : parseEvent(eventReturn, eventKey);\n  };\n  const compileCallbacks = eventReturn => {\n    const getCallback = obj => isFunction(obj.callback) && obj.callback;\n    const callbacks = Array.isArray(eventReturn) ? eventReturn.map(evtObj => getCallback(evtObj)) : [getCallback(eventReturn)];\n    const callbackArray = callbacks.filter(callback => callback !== false);\n    return callbackArray.length ? () => callbackArray.forEach(callback => callback()) : undefined;\n  };\n\n  // A function that calls a particular event handler, parses its return\n  // into a state mutation, and calls setState\n  // eslint-disable-next-line max-params\n  const onEvent = (evt, childProps, eventKey, eventName) => {\n    // eslint-disable-next-line no-invalid-this\n    const eventReturn = events[eventName](evt, childProps, eventKey, this);\n    if (!_isEmpty(eventReturn)) {\n      const callbacks = compileCallbacks(eventReturn);\n      // eslint-disable-next-line no-invalid-this\n      this.setState(parseEventReturn(eventReturn, eventKey), callbacks);\n    }\n  };\n\n  // returns a new events object with enhanced event handlers\n  return Object.keys(events).reduce((memo, event) => {\n    memo[event] = onEvent;\n    return memo;\n  }, {});\n}\n\n/*\n * Returns a partially applied event handler for a specific target element\n * This allows event handlers to have access to props controlling each element\n */\nexport function getPartialEvents(events, eventKey, childProps) {\n  if (!events) return {};\n  return Object.keys(events).reduce((memo, eventName) => {\n    const appliedEvent = evt => events[eventName](evt, childProps, eventKey, eventName);\n    memo[eventName] = appliedEvent;\n    return memo;\n  }, {});\n}\n/* Returns the property of the state object corresponding to event changes for\n * a particular element\n */\n// eslint-disable-next-line max-params\nexport function getEventState(eventKey, namespace, childType) {\n  // Mandatory usage: `getEventState.bind(this)`\n  // eslint-disable-next-line no-invalid-this\n  const state = this.state || {};\n  if (!childType) {\n    return eventKey === \"parent\" ? state[eventKey] && state[eventKey][namespace] || state[eventKey] : state[eventKey] && state[eventKey][namespace];\n  }\n  return state[childType] && state[childType][eventKey] && state[childType][eventKey][namespace];\n}\n\n/**\n * Returns a set of all mutations for shared events\n *\n * @param  {Array} mutations an array of mutations objects\n * @param  {Object} baseProps an object that describes all props for children of VictorySharedEvents\n * @param  {Object} baseState an object that describes state for children of VictorySharedEvents\n * @param  {Array} childNames an array of childNames\n *\n * @return {Object} a object describing all mutations for VictorySharedEvents\n */\n// eslint-disable-next-line max-params\nexport function getExternalMutationsWithChildren(mutations, baseProps, baseState, childNames) {\n  if (baseProps === void 0) {\n    baseProps = {};\n  }\n  if (baseState === void 0) {\n    baseState = {};\n  }\n  return childNames.reduce((memo, childName) => {\n    const childState = baseState[childName];\n    const mutation = getExternalMutations(mutations, baseProps[childName], baseState[childName], childName);\n    memo[childName] = mutation ? mutation : childState;\n    return _pickBy(memo, v => !_isEmpty(v));\n  }, {});\n}\n\n/**\n * Returns a set of all mutations for a component\n *\n * @param  {Array} mutations an array of mutations objects\n * @param  {Object} baseProps a props object (scoped to a childName when used by shared events)\n * @param  {Object} baseState a state object (scoped to a childName when used by shared events)\n * @param  {String} childName an optional childName\n *\n * @return {Object} a object describing mutations for a given component\n */\n// eslint-disable-next-line max-params\nexport function getExternalMutations(mutations, baseProps, baseState, childName) {\n  if (baseProps === void 0) {\n    baseProps = {};\n  }\n  if (baseState === void 0) {\n    baseState = {};\n  }\n  const eventKeys = Object.keys(baseProps);\n  return eventKeys.reduce((memo, eventKey) => {\n    const keyState = baseState[eventKey] || {};\n    const keyProps = baseProps[eventKey] || {};\n    if (eventKey === \"parent\") {\n      const identifier = {\n        eventKey,\n        target: \"parent\"\n      };\n      const mutation = getExternalMutation(mutations, keyProps, keyState, identifier);\n      memo[eventKey] = mutation !== undefined ? Object.assign({}, keyState, mutation) : keyState;\n    } else {\n      // use keys from both state and props so that elements not intially included in baseProps\n      // will be used. (i.e. labels)\n      const targets = _uniq(Object.keys(keyProps).concat(Object.keys(keyState)));\n      memo[eventKey] = targets.reduce((m, target) => {\n        const identifier = {\n          eventKey,\n          target,\n          childName\n        };\n        const mutation = getExternalMutation(mutations, keyProps[target], keyState[target], identifier);\n        m[target] = mutation !== undefined ? Object.assign({}, keyState[target], mutation) : keyState[target];\n        return _pickBy(m, v => !_isEmpty(v));\n      }, {});\n    }\n    return _pickBy(memo, v => !_isEmpty(v));\n  }, {});\n}\n\n/**\n * Returns a set of mutations for a particular element given scoped baseProps and baseState\n *\n * @param  {Array} mutations an array of mutations objects\n * @param  {Object} baseProps a props object (scoped the element specified by the identifier)\n * @param  {Object} baseState a state object (scoped the element specified by the identifier)\n * @param  {Object} identifier { eventKey, target, childName }\n *\n * @return {Object | undefined} a object describing mutations for a given element, or undefined\n */\n// eslint-disable-next-line max-params\nexport function getExternalMutation(mutations, baseProps, baseState, identifier) {\n  const filterMutations = (mutation, type) => {\n    if (typeof mutation[type] === \"string\") {\n      return mutation[type] === \"all\" || mutation[type] === identifier[type];\n    } else if (Array.isArray(mutation[type])) {\n      // coerce arrays to strings before matching\n      const stringArray = mutation[type].map(m => `${m}`);\n      return stringArray.includes(identifier[type]);\n    }\n    return false;\n  };\n  let scopedMutations = Array.isArray(mutations) ? mutations : [mutations];\n  if (identifier.childName) {\n    scopedMutations = mutations.filter(m => filterMutations(m, \"childName\"));\n  }\n  // find any mutation objects that match the target\n  const targetMutations = scopedMutations.filter(m => filterMutations(m, \"target\"));\n  if (_isEmpty(targetMutations)) {\n    return undefined;\n  }\n  const keyMutations = targetMutations.filter(m => filterMutations(m, \"eventKey\"));\n  if (_isEmpty(keyMutations)) {\n    return undefined;\n  }\n  return keyMutations.reduce((memo, curr) => {\n    const mutationFunction = curr && isFunction(curr.mutation) ? curr.mutation : () => undefined;\n    const currentMutation = mutationFunction(Object.assign({}, baseProps, baseState));\n    return Object.assign({}, memo, currentMutation);\n  }, {});\n}\n\n/* Returns an array of defaultEvents from sub-components of a given component.\n * i.e. any static `defaultEvents` on `labelComponent` will be returned\n */\nexport function getComponentEvents(props, components) {\n  const events = Array.isArray(components) && components.reduce((memo, componentName) => {\n    const component = props[componentName];\n    const defaultEvents = component && component.type && component.type.defaultEvents;\n    const componentEvents = isFunction(defaultEvents) ? defaultEvents(component.props) : defaultEvents;\n    return Array.isArray(componentEvents) ? memo.concat(...componentEvents) : memo;\n  }, []);\n  return events && events.length ? events : undefined;\n}\nexport function getGlobalEventNameFromKey(key) {\n  const match = key.match(GLOBAL_EVENT_REGEX);\n  return match && match[1] && match[1].toLowerCase();\n}\nexport const getGlobalEvents = events => _pickBy(events, (_, key) => GLOBAL_EVENT_REGEX.test(key));\nexport const omitGlobalEvents = events => _omitBy(events, (_, key) => GLOBAL_EVENT_REGEX.test(key));\nexport const emulateReactEvent = event => Object.assign(event, {\n  nativeEvent: event\n});","map":{"version":3,"names":["_uniq","_omitBy","_pickBy","_isEmpty","isFunction","GLOBAL_EVENT_REGEX","getEvents","props","target","eventKey","getScopedEvents","getEventsByTarget","events","getSelectedEvents","targetEvents","reduce","memo","event","undefined","matchesTarget","Array","isArray","includes","concat","filter","obj","targetKeys","useKey","key","some","k","selectedEvents","Object","assign","eventHandlers","getAllEvents","componentEvents","allEvents","ownEvents","sharedEvents","getSharedEvents","namespace","childType","baseProps","newBaseProps","getTargetProps","identifier","type","childName","baseType","state","base","parent","parseEvent","eventReturn","childNames","getKeys","keys","value","getMutationObject","baseState","mutation","mutationTargetProps","mutationTargetState","mutatedProps","childState","filterState","length","extendState","updateState","getReturnByChild","mutationKeys","allChildNames","parseEventReturn","compileCallbacks","getCallback","callback","callbacks","map","evtObj","callbackArray","forEach","onEvent","evt","childProps","eventName","setState","getPartialEvents","appliedEvent","getEventState","getExternalMutationsWithChildren","mutations","getExternalMutations","v","eventKeys","keyState","keyProps","getExternalMutation","targets","m","filterMutations","stringArray","scopedMutations","targetMutations","keyMutations","curr","mutationFunction","currentMutation","getComponentEvents","components","componentName","component","defaultEvents","getGlobalEventNameFromKey","match","toLowerCase","getGlobalEvents","_","test","omitGlobalEvents","emulateReactEvent","nativeEvent"],"sources":["/Users/anjalichaturvedi/GitHub/brew-bridge-dashboard/website/node_modules/victory-core/es/victory-util/events.js"],"sourcesContent":["import _uniq from \"lodash/uniq\";\nimport _omitBy from \"lodash/omitBy\";\nimport _pickBy from \"lodash/pickBy\";\nimport _isEmpty from \"lodash/isEmpty\";\n/* eslint-disable no-use-before-define */\nimport { isFunction } from \"./helpers\";\nconst GLOBAL_EVENT_REGEX = /^onGlobal(.*)$/;\n\n// Normally we'd use Template Literal Types, but we're avoiding it to maximize TS compatibility with TS < 4.1\n// `on${Capitalize<string>}`;\n\n/* Returns all own and shared events that should be attached to a single target element,\n * i.e. an individual bar specified by target: \"data\", eventKey: [index].\n * Returned events are scoped to the appropriate state. Either that of the component itself\n * (i.e. VictoryBar) in the case of own events, or that of the parent component\n * (i.e. VictoryChart) in the case of shared events\n */\n// eslint-disable-next-line max-params\nexport function getEvents(props, target, eventKey,\n// eslint-disable-next-line no-shadow\ngetScopedEvents) {\n  // Returns all events that apply to a particular target element\n  const getEventsByTarget = events => {\n    const getSelectedEvents = () => {\n      const targetEvents = events.reduce((memo, event) => {\n        if (event.target !== undefined) {\n          const matchesTarget = Array.isArray(event.target) ? event.target.includes(target) : `${event.target}` === `${target}`;\n          return matchesTarget ? memo.concat(event) : memo;\n        }\n        return memo.concat(event);\n      }, []);\n      if (eventKey !== undefined && target !== \"parent\") {\n        return targetEvents.filter(obj => {\n          const targetKeys = obj.eventKey;\n          const useKey = key => key ? `${key}` === `${eventKey}` : true;\n          return Array.isArray(targetKeys) ? targetKeys.some(k => useKey(k)) : useKey(targetKeys);\n        });\n      }\n      return targetEvents;\n    };\n    const selectedEvents = getSelectedEvents();\n    return Array.isArray(selectedEvents) && selectedEvents.reduce((memo, event) => {\n      return event ? Object.assign(memo, event.eventHandlers) : memo;\n    }, {});\n  };\n\n  /* Returns all events from props and defaultEvents from components. Events handlers\n   * specified in props will override handlers for the same event if they are also\n   * specified in defaultEvents of a sub-component\n   */\n  const getAllEvents = () => {\n    // Mandatory usage: `getEvents.bind(this)`\n    /* eslint-disable no-invalid-this */\n    if (Array.isArray(this.componentEvents)) {\n      return Array.isArray(props.events) ? this.componentEvents.concat(...props.events) : this.componentEvents;\n    }\n    /* eslint-enable no-invalid-this */\n    return props.events;\n  };\n  const allEvents = getAllEvents();\n  const ownEvents = allEvents && isFunction(getScopedEvents) ? getScopedEvents(getEventsByTarget(allEvents), target) : undefined;\n  if (!props.sharedEvents) {\n    return ownEvents;\n  }\n  const getSharedEvents = props.sharedEvents.getEvents;\n  const sharedEvents = props.sharedEvents.events && getSharedEvents(getEventsByTarget(props.sharedEvents.events), target);\n  return Object.assign({}, sharedEvents, ownEvents);\n}\n\n/* Returns a modified events object where each event handler is replaced by a new\n * function that calls the original handler and then calls setState with the return\n * of the original event handler assigned to state property that maps to the target\n * element.\n */\n// eslint-disable-next-line max-params\nexport function getScopedEvents(events, namespace, childType, baseProps) {\n  if (_isEmpty(events)) {\n    return {};\n  }\n\n  // Mandatory usage: `getScopedEvents.bind(this)`\n  // eslint-disable-next-line no-invalid-this\n  const newBaseProps = baseProps || this.baseProps;\n  // returns the original base props or base state of a given target element\n  const getTargetProps = (identifier, type) => {\n    const {\n      childName,\n      target,\n      key\n    } = identifier;\n    // eslint-disable-next-line no-invalid-this\n    const baseType = type === \"props\" ? newBaseProps : this.state || {};\n    const base = childName === undefined || childName === null || !baseType[childName] ? baseType : baseType[childName];\n    return key === \"parent\" ? base.parent : base[key] && base[key][target];\n  };\n\n  // Returns the state object with the mutation caused by a given eventReturn\n  // applied to the appropriate property on the state object\n  const parseEvent = (eventReturn, eventKey) => {\n    const childNames = namespace === \"parent\" ? eventReturn.childName : eventReturn.childName || childType;\n    const target = eventReturn.target || namespace;\n\n    // returns all eventKeys to modify for a targeted childName\n    const getKeys = childName => {\n      if (target === \"parent\") {\n        return \"parent\";\n      }\n      if (eventReturn.eventKey === \"all\") {\n        return newBaseProps[childName] ? Object.keys(newBaseProps[childName]).filter(value => value !== \"parent\") : Object.keys(newBaseProps).filter(value => value !== \"parent\");\n      } else if (eventReturn.eventKey === undefined && eventKey === \"parent\") {\n        return newBaseProps[childName] ? Object.keys(newBaseProps[childName]) : Object.keys(newBaseProps);\n      }\n      return eventReturn.eventKey !== undefined ? eventReturn.eventKey : eventKey;\n    };\n\n    // returns the state object with mutated props applied for a single key\n    const getMutationObject = (key, childName) => {\n      // eslint-disable-next-line no-invalid-this\n      const baseState = this.state || {};\n      if (!isFunction(eventReturn.mutation)) {\n        return baseState;\n      }\n      const mutationTargetProps = getTargetProps({\n        childName,\n        key,\n        target\n      }, \"props\");\n      const mutationTargetState = getTargetProps({\n        childName,\n        key,\n        target\n      }, \"state\");\n      const mutatedProps = eventReturn.mutation(Object.assign({}, mutationTargetProps, mutationTargetState), newBaseProps);\n      const childState = baseState[childName] || {};\n      const filterState = state => {\n        if (state[key] && state[key][target]) {\n          delete state[key][target];\n        }\n        if (state[key] && !Object.keys(state[key]).length) {\n          delete state[key];\n        }\n        return state;\n      };\n      const extendState = state => {\n        return target === \"parent\" ? Object.assign(state, {\n          [key]: Object.assign(state[key] || {}, mutatedProps)\n        }) : Object.assign(state, {\n          [key]: Object.assign(state[key] || {}, {\n            [target]: mutatedProps\n          })\n        });\n      };\n      const updateState = state => {\n        return mutatedProps ? extendState(state) : filterState(state);\n      };\n      return childName !== undefined && childName !== null ? Object.assign(baseState, {\n        [childName]: updateState(childState)\n      }) : updateState(baseState);\n    };\n\n    // returns entire mutated state for a given childName\n    const getReturnByChild = childName => {\n      const mutationKeys = getKeys(childName);\n      return Array.isArray(mutationKeys) ? mutationKeys.reduce((memo, key) => {\n        return Object.assign(memo, getMutationObject(key, childName));\n      }, {}) : getMutationObject(mutationKeys, childName);\n    };\n\n    // returns an entire mutated state for all children\n    const allChildNames = childNames === \"all\" ? Object.keys(newBaseProps).filter(value => value !== \"parent\") : childNames;\n    return Array.isArray(allChildNames) ? allChildNames.reduce((memo, childName) => {\n      return Object.assign(memo, getReturnByChild(childName));\n    }, {}) : getReturnByChild(allChildNames);\n  };\n\n  // Parses an array of event returns into a single state mutation\n  const parseEventReturn = (eventReturn, eventKey) => {\n    return Array.isArray(eventReturn) ? eventReturn.reduce((memo, props) => Object.assign({}, memo, parseEvent(props, eventKey)), {}) : parseEvent(eventReturn, eventKey);\n  };\n  const compileCallbacks = eventReturn => {\n    const getCallback = obj => isFunction(obj.callback) && obj.callback;\n    const callbacks = Array.isArray(eventReturn) ? eventReturn.map(evtObj => getCallback(evtObj)) : [getCallback(eventReturn)];\n    const callbackArray = callbacks.filter(callback => callback !== false);\n    return callbackArray.length ? () => callbackArray.forEach(callback => callback()) : undefined;\n  };\n\n  // A function that calls a particular event handler, parses its return\n  // into a state mutation, and calls setState\n  // eslint-disable-next-line max-params\n  const onEvent = (evt, childProps, eventKey, eventName) => {\n    // eslint-disable-next-line no-invalid-this\n    const eventReturn = events[eventName](evt, childProps, eventKey, this);\n    if (!_isEmpty(eventReturn)) {\n      const callbacks = compileCallbacks(eventReturn);\n      // eslint-disable-next-line no-invalid-this\n      this.setState(parseEventReturn(eventReturn, eventKey), callbacks);\n    }\n  };\n\n  // returns a new events object with enhanced event handlers\n  return Object.keys(events).reduce((memo, event) => {\n    memo[event] = onEvent;\n    return memo;\n  }, {});\n}\n\n/*\n * Returns a partially applied event handler for a specific target element\n * This allows event handlers to have access to props controlling each element\n */\nexport function getPartialEvents(events, eventKey, childProps) {\n  if (!events) return {};\n  return Object.keys(events).reduce((memo, eventName) => {\n    const appliedEvent = evt => events[eventName](evt, childProps, eventKey, eventName);\n    memo[eventName] = appliedEvent;\n    return memo;\n  }, {});\n}\n/* Returns the property of the state object corresponding to event changes for\n * a particular element\n */\n// eslint-disable-next-line max-params\nexport function getEventState(eventKey, namespace, childType) {\n  // Mandatory usage: `getEventState.bind(this)`\n  // eslint-disable-next-line no-invalid-this\n  const state = this.state || {};\n  if (!childType) {\n    return eventKey === \"parent\" ? state[eventKey] && state[eventKey][namespace] || state[eventKey] : state[eventKey] && state[eventKey][namespace];\n  }\n  return state[childType] && state[childType][eventKey] && state[childType][eventKey][namespace];\n}\n\n/**\n * Returns a set of all mutations for shared events\n *\n * @param  {Array} mutations an array of mutations objects\n * @param  {Object} baseProps an object that describes all props for children of VictorySharedEvents\n * @param  {Object} baseState an object that describes state for children of VictorySharedEvents\n * @param  {Array} childNames an array of childNames\n *\n * @return {Object} a object describing all mutations for VictorySharedEvents\n */\n// eslint-disable-next-line max-params\nexport function getExternalMutationsWithChildren(mutations, baseProps, baseState, childNames) {\n  if (baseProps === void 0) {\n    baseProps = {};\n  }\n  if (baseState === void 0) {\n    baseState = {};\n  }\n  return childNames.reduce((memo, childName) => {\n    const childState = baseState[childName];\n    const mutation = getExternalMutations(mutations, baseProps[childName], baseState[childName], childName);\n    memo[childName] = mutation ? mutation : childState;\n    return _pickBy(memo, v => !_isEmpty(v));\n  }, {});\n}\n\n/**\n * Returns a set of all mutations for a component\n *\n * @param  {Array} mutations an array of mutations objects\n * @param  {Object} baseProps a props object (scoped to a childName when used by shared events)\n * @param  {Object} baseState a state object (scoped to a childName when used by shared events)\n * @param  {String} childName an optional childName\n *\n * @return {Object} a object describing mutations for a given component\n */\n// eslint-disable-next-line max-params\nexport function getExternalMutations(mutations, baseProps, baseState, childName) {\n  if (baseProps === void 0) {\n    baseProps = {};\n  }\n  if (baseState === void 0) {\n    baseState = {};\n  }\n  const eventKeys = Object.keys(baseProps);\n  return eventKeys.reduce((memo, eventKey) => {\n    const keyState = baseState[eventKey] || {};\n    const keyProps = baseProps[eventKey] || {};\n    if (eventKey === \"parent\") {\n      const identifier = {\n        eventKey,\n        target: \"parent\"\n      };\n      const mutation = getExternalMutation(mutations, keyProps, keyState, identifier);\n      memo[eventKey] = mutation !== undefined ? Object.assign({}, keyState, mutation) : keyState;\n    } else {\n      // use keys from both state and props so that elements not intially included in baseProps\n      // will be used. (i.e. labels)\n      const targets = _uniq(Object.keys(keyProps).concat(Object.keys(keyState)));\n      memo[eventKey] = targets.reduce((m, target) => {\n        const identifier = {\n          eventKey,\n          target,\n          childName\n        };\n        const mutation = getExternalMutation(mutations, keyProps[target], keyState[target], identifier);\n        m[target] = mutation !== undefined ? Object.assign({}, keyState[target], mutation) : keyState[target];\n        return _pickBy(m, v => !_isEmpty(v));\n      }, {});\n    }\n    return _pickBy(memo, v => !_isEmpty(v));\n  }, {});\n}\n\n/**\n * Returns a set of mutations for a particular element given scoped baseProps and baseState\n *\n * @param  {Array} mutations an array of mutations objects\n * @param  {Object} baseProps a props object (scoped the element specified by the identifier)\n * @param  {Object} baseState a state object (scoped the element specified by the identifier)\n * @param  {Object} identifier { eventKey, target, childName }\n *\n * @return {Object | undefined} a object describing mutations for a given element, or undefined\n */\n// eslint-disable-next-line max-params\nexport function getExternalMutation(mutations, baseProps, baseState, identifier) {\n  const filterMutations = (mutation, type) => {\n    if (typeof mutation[type] === \"string\") {\n      return mutation[type] === \"all\" || mutation[type] === identifier[type];\n    } else if (Array.isArray(mutation[type])) {\n      // coerce arrays to strings before matching\n      const stringArray = mutation[type].map(m => `${m}`);\n      return stringArray.includes(identifier[type]);\n    }\n    return false;\n  };\n  let scopedMutations = Array.isArray(mutations) ? mutations : [mutations];\n  if (identifier.childName) {\n    scopedMutations = mutations.filter(m => filterMutations(m, \"childName\"));\n  }\n  // find any mutation objects that match the target\n  const targetMutations = scopedMutations.filter(m => filterMutations(m, \"target\"));\n  if (_isEmpty(targetMutations)) {\n    return undefined;\n  }\n  const keyMutations = targetMutations.filter(m => filterMutations(m, \"eventKey\"));\n  if (_isEmpty(keyMutations)) {\n    return undefined;\n  }\n  return keyMutations.reduce((memo, curr) => {\n    const mutationFunction = curr && isFunction(curr.mutation) ? curr.mutation : () => undefined;\n    const currentMutation = mutationFunction(Object.assign({}, baseProps, baseState));\n    return Object.assign({}, memo, currentMutation);\n  }, {});\n}\n\n/* Returns an array of defaultEvents from sub-components of a given component.\n * i.e. any static `defaultEvents` on `labelComponent` will be returned\n */\nexport function getComponentEvents(props, components) {\n  const events = Array.isArray(components) && components.reduce((memo, componentName) => {\n    const component = props[componentName];\n    const defaultEvents = component && component.type && component.type.defaultEvents;\n    const componentEvents = isFunction(defaultEvents) ? defaultEvents(component.props) : defaultEvents;\n    return Array.isArray(componentEvents) ? memo.concat(...componentEvents) : memo;\n  }, []);\n  return events && events.length ? events : undefined;\n}\nexport function getGlobalEventNameFromKey(key) {\n  const match = key.match(GLOBAL_EVENT_REGEX);\n  return match && match[1] && match[1].toLowerCase();\n}\nexport const getGlobalEvents = events => _pickBy(events, (_, key) => GLOBAL_EVENT_REGEX.test(key));\nexport const omitGlobalEvents = events => _omitBy(events, (_, key) => GLOBAL_EVENT_REGEX.test(key));\nexport const emulateReactEvent = event => Object.assign(event, {\n  nativeEvent: event\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
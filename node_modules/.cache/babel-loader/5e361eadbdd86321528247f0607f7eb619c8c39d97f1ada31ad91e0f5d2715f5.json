{"ast":null,"code":"import * as d3Shape from \"victory-vendor/d3-shape\";\nimport { circle, point } from \"./geometry-helper-methods\";\nconst getPosition = (props, width) => {\n  const {\n    x,\n    x0,\n    y,\n    y0,\n    horizontal\n  } = props;\n  const alignment = props.alignment || \"middle\";\n  const size = alignment === \"middle\" ? width / 2 : width;\n  const sign = horizontal ? -1 : 1;\n  if (horizontal) {\n    return {\n      x0,\n      x1: x,\n      y0: alignment === \"start\" ? y : y - sign * size,\n      y1: alignment === \"end\" ? y : y + sign * size\n    };\n  }\n  return {\n    x0: alignment === \"start\" ? x : x - sign * size,\n    x1: alignment === \"end\" ? x : x + sign * size,\n    y0,\n    y1: y\n  };\n};\nconst getAngle = (props, index) => {\n  const {\n    data,\n    scale\n  } = props;\n  const x = data[index]._x1 === undefined ? \"_x\" : \"_x1\";\n  return scale.x(data[index][x]);\n};\nconst getAngularWidth = (props, width) => {\n  const {\n    scale\n  } = props;\n  const range = scale.y.range();\n  const r = Math.max(...range);\n  const angularRange = Math.abs(scale.x.range()[1] - scale.x.range()[0]);\n  return width / (2 * Math.PI * r) * angularRange;\n};\nconst transformAngle = angle => {\n  return -1 * angle + Math.PI / 2;\n};\nexport const getCustomBarPath = (props, width) => {\n  const {\n    getPath\n  } = props;\n  if (typeof getPath === \"function\") {\n    const propsWithCalculatedValues = {\n      ...props,\n      ...getPosition(props, width)\n    };\n    return getPath(propsWithCalculatedValues);\n  }\n};\nconst getStartAngle = (props, index) => {\n  const {\n    data,\n    scale,\n    alignment\n  } = props;\n  const currentAngle = getAngle(props, index);\n  const angularRange = Math.abs(scale.x.range()[1] - scale.x.range()[0]);\n  const previousAngle = index === 0 ? getAngle(props, data.length - 1) - Math.PI * 2 : getAngle(props, index - 1);\n  if (index === 0 && angularRange < 2 * Math.PI) {\n    return scale.x.range()[0];\n  } else if (alignment === \"start\" || alignment === \"end\") {\n    return alignment === \"start\" ? previousAngle : currentAngle;\n  }\n  return (currentAngle + previousAngle) / 2;\n};\nconst getEndAngle = (props, index) => {\n  const {\n    data,\n    scale,\n    alignment\n  } = props;\n  const currentAngle = getAngle(props, index);\n  const angularRange = Math.abs(scale.x.range()[1] - scale.x.range()[0]);\n  const lastAngle = scale.x.range()[1] === 2 * Math.PI ? getAngle(props, 0) + Math.PI * 2 : scale.x.range()[1];\n  const nextAngle = index === data.length - 1 ? getAngle(props, 0) + Math.PI * 2 : getAngle(props, index + 1);\n  if (index === data.length - 1 && angularRange < 2 * Math.PI) {\n    return lastAngle;\n  } else if (alignment === \"start\" || alignment === \"end\") {\n    return alignment === \"start\" ? currentAngle : nextAngle;\n  }\n  return (currentAngle + nextAngle) / 2;\n};\nconst mapPointsToPath = (coords, cornerRadius, direction) => {\n  const topLeftPath = `${cornerRadius.topLeft} ${cornerRadius.topLeft} ${direction}`;\n  const topRightPath = `${cornerRadius.topRight} ${cornerRadius.topRight} ${direction}`;\n  const bottomLeftPath = `${cornerRadius.bottomLeft} ${cornerRadius.bottomLeft} ${direction}`;\n  const bottomRightPath = `${cornerRadius.bottomRight} ${cornerRadius.bottomRight} ${direction}`;\n  const commands = [\"M\", `A ${bottomLeftPath},`, \"L\", `A ${topLeftPath},`, \"L\", `A ${topRightPath},`, \"L\", `A ${bottomRightPath},`];\n  const path = commands.reduce((acc, command, i) => `${acc}${command} ${coords[i].x}, ${coords[i].y} \\n`, \"\");\n  return `${path} z`;\n};\nconst getVerticalBarPoints = (position, sign, cr) => {\n  const {\n    x0,\n    x1,\n    y0,\n    y1\n  } = position;\n\n  // eslint-disable-next-line max-statements, max-len\n  const getHalfPoints = side => {\n    const isLeft = side === \"Left\";\n    const signL = isLeft ? 1 : -1;\n    const x = isLeft ? x0 : x1;\n    let bottomPoint = {\n      x: x + signL * cr[`bottom${side}`],\n      y: y0\n    };\n    let bottomMiddlePoint = {\n      x,\n      y: y0 - sign * cr[`bottom${side}`]\n    };\n    let topMiddlePoint = {\n      x,\n      y: y1 + sign * cr[`top${side}`]\n    };\n    let topPoint = {\n      x: x + signL * cr[`top${side}`],\n      y: y1\n    };\n    const hasIntersection = sign === 1 ? y0 - cr[`bottom${side}`] < y1 + cr[`top${side}`] : y0 + cr[`bottom${side}`] > y1 - cr[`top${side}`];\n    if (hasIntersection) {\n      const topCenter = point(x + signL * cr[`top${side}`], y1 + sign * cr[`top${side}`]);\n      const topCircle = circle(topCenter, cr[`top${side}`]);\n      const bottomCenter = point(x + signL * cr[`bottom${side}`], y0 - sign * cr[`bottom${side}`]);\n      const bottomCircle = circle(bottomCenter, cr[`bottom${side}`]);\n      const circleIntersection = topCircle.intersection(bottomCircle);\n      const hasArcIntersection = circleIntersection.length > 0;\n      if (hasArcIntersection) {\n        const arcIntersection = circleIntersection[isLeft ? 0 : 1];\n        bottomMiddlePoint = {\n          x: arcIntersection.x,\n          y: arcIntersection.y\n        };\n        topMiddlePoint = {\n          x: arcIntersection.x,\n          y: arcIntersection.y\n        };\n      } else {\n        const hasBottomLineTopArcIntersection = cr[`top${side}`] > cr[`bottom${side}`];\n        if (hasBottomLineTopArcIntersection) {\n          const newX = topCircle.solveX(y0)[isLeft ? 0 : 1];\n          bottomPoint = {\n            x: newX,\n            y: y0\n          };\n          bottomMiddlePoint = {\n            x: newX,\n            y: y0\n          };\n          topMiddlePoint = {\n            x: newX,\n            y: y0\n          };\n        } else {\n          const newX = bottomCircle.solveX(y1)[isLeft ? 0 : 1];\n          bottomMiddlePoint = {\n            x: newX,\n            y: y1\n          };\n          topMiddlePoint = {\n            x: newX,\n            y: y1\n          };\n          topPoint = {\n            x: newX,\n            y: y1\n          };\n        }\n      }\n    }\n    const points = [bottomPoint, bottomMiddlePoint, topMiddlePoint, topPoint];\n    return isLeft ? points : points.reverse();\n  };\n  return getHalfPoints(\"Left\").concat(getHalfPoints(\"Right\"));\n};\nconst getHorizontalBarPoints = (position, sign, cr) => {\n  const {\n    y0,\n    y1\n  } = position;\n  const x0 = position.x0 < position.x1 ? position.x0 : position.x1;\n  const x1 = position.x0 < position.x1 ? position.x1 : position.x0;\n\n  // eslint-disable-next-line max-statements, max-len\n  const getHalfPoints = side => {\n    const isTop = side === \"top\";\n    const signL = isTop ? -1 : 1;\n    const y = isTop ? y1 : y0;\n    let leftPoint = {\n      x: x0,\n      y: y - signL * cr[`${side}Left`]\n    };\n    let leftMiddlePoint = {\n      x: x0 + cr[`${side}Left`],\n      y\n    };\n    let rightMiddlePoint = {\n      x: x1 - cr[`${side}Right`],\n      y\n    };\n    let rightPoint = {\n      x: x1,\n      y: y - signL * cr[`${side}Right`]\n    };\n    const hasIntersection = leftMiddlePoint.x > rightMiddlePoint.x;\n    if (hasIntersection) {\n      const leftCenter = point(x0 + cr[`${side}Left`], y - signL * cr[`${side}Left`]);\n      const leftCircle = circle(leftCenter, cr[`${side}Left`]);\n      const rightCenter = point(x1 - cr[`${side}Right`], y - signL * cr[`${side}Right`]);\n      const rightCircle = circle(rightCenter, cr[`${side}Right`]);\n      const circleIntersection = leftCircle.intersection(rightCircle);\n      const hasArcIntersection = circleIntersection.length > 0;\n      if (hasArcIntersection) {\n        const arcIntersection = circleIntersection[sign > 0 ? 1 : 0];\n        leftMiddlePoint = {\n          x: arcIntersection.x,\n          y: arcIntersection.y\n        };\n        rightMiddlePoint = {\n          x: arcIntersection.x,\n          y: arcIntersection.y\n        };\n      } else {\n        const hasLeftLineRightArcIntersection = cr[`${side}Right`] > cr[`${side}Left`];\n        if (hasLeftLineRightArcIntersection) {\n          const newY = rightCircle.solveY(x0)[isTop ? 0 : 1];\n          leftPoint = {\n            x: x0,\n            y: newY\n          };\n          leftMiddlePoint = {\n            x: x0,\n            y: newY\n          };\n          rightMiddlePoint = {\n            x: x0,\n            y: newY\n          };\n        } else {\n          const newY = leftCircle.solveY(x1)[isTop ? 0 : 1];\n          rightPoint = {\n            x: x1,\n            y: newY\n          };\n          rightMiddlePoint = {\n            x: x1,\n            y: newY\n          };\n          leftMiddlePoint = {\n            x: x1,\n            y: newY\n          };\n        }\n      }\n    }\n    return [leftPoint, leftMiddlePoint, rightMiddlePoint, rightPoint];\n  };\n  const topPoints = getHalfPoints(\"top\");\n  const bottomPoints = getHalfPoints(\"bottom\");\n  return [bottomPoints[1], bottomPoints[0], ...topPoints,\n  // eslint-disable-next-line no-magic-numbers\n  bottomPoints[3], bottomPoints[2]];\n};\n\n// eslint-disable-next-line max-params\nexport const getVerticalBarPath = (props, width, cornerRadius) => {\n  const position = getPosition(props, width);\n  const sign = position.y0 > position.y1 ? 1 : -1;\n  const direction = sign > 0 ? \"0 0 1\" : \"0 0 0\";\n  const points = getVerticalBarPoints(position, sign, cornerRadius);\n  return mapPointsToPath(points, cornerRadius, direction);\n};\n\n// eslint-disable-next-line max-params\nexport const getHorizontalBarPath = (props, width, cornerRadius) => {\n  const position = getPosition(props, width);\n  const sign = position.x0 < position.x1 ? 1 : -1;\n  const direction = \"0 0 1\";\n  const cr = {\n    topRight: sign > 0 ? cornerRadius.topLeft : cornerRadius.bottomLeft,\n    bottomRight: sign > 0 ? cornerRadius.topRight : cornerRadius.bottomRight,\n    bottomLeft: sign > 0 ? cornerRadius.bottomRight : cornerRadius.topRight,\n    topLeft: sign > 0 ? cornerRadius.bottomLeft : cornerRadius.topLeft\n  };\n  const points = getHorizontalBarPoints(position, sign, cr);\n  return mapPointsToPath(points, cr, direction);\n};\nexport const getVerticalPolarBarPath = (props, cornerRadius) => {\n  const {\n    datum,\n    scale,\n    index,\n    alignment,\n    style\n  } = props;\n  const r1 = scale.y(datum._y0 || 0);\n  const r2 = scale.y(datum._y1 !== undefined ? datum._y1 : datum._y);\n  const currentAngle = scale.x(datum._x1 !== undefined ? datum._x1 : datum._x);\n  let start;\n  let end;\n  if (style.width) {\n    const width = getAngularWidth(props, style.width);\n    const size = alignment === \"middle\" ? width / 2 : width;\n    start = alignment === \"start\" ? currentAngle : currentAngle - size;\n    end = alignment === \"end\" ? currentAngle : currentAngle + size;\n  } else {\n    start = getStartAngle(props, Number(index));\n    end = getEndAngle(props, Number(index));\n  }\n  const getPath = edge => {\n    const pathFunction = d3Shape.arc().innerRadius(r1).outerRadius(r2).startAngle(transformAngle(start)).endAngle(transformAngle(end)).cornerRadius(cornerRadius[edge]);\n    return pathFunction();\n  };\n  const getPathData = edge => {\n    const rightPath = getPath(`${edge}Right`);\n    const rightMoves = rightPath.match(/[A-Z]/g) || [];\n    const rightCoords = rightPath.split(/[A-Z]/).slice(1);\n    const rightMiddle = rightMoves.indexOf(\"L\");\n    const leftPath = getPath(`${edge}Left`);\n    const leftMoves = leftPath.match(/[A-Z]/g) || [];\n    const leftCoords = leftPath.split(/[A-Z]/).slice(1);\n    const leftMiddle = leftMoves.indexOf(\"L\");\n    return {\n      rightMoves,\n      rightCoords,\n      rightMiddle,\n      leftMoves,\n      leftCoords,\n      leftMiddle\n    };\n  };\n\n  // eslint-disable-next-line max-statements\n  const getTopPath = () => {\n    const {\n      topRight,\n      topLeft\n    } = cornerRadius;\n    const arcLength = r2 * Math.abs(end - start);\n    const {\n      rightMoves,\n      rightCoords,\n      rightMiddle,\n      leftMoves,\n      leftCoords,\n      leftMiddle\n    } = getPathData(\"top\");\n    let moves;\n    let coords;\n    if (topRight === topLeft || arcLength < 2 * topRight + 2 * topLeft) {\n      moves = topRight > topLeft ? rightMoves : leftMoves;\n      coords = topRight > topLeft ? rightCoords : leftCoords;\n    } else {\n      // eslint-disable-next-line no-magic-numbers\n      const isShort = middle => middle < 3;\n      const rightOffset = topLeft > topRight && isShort(rightMiddle) ? 1 : 2;\n      let leftOffset;\n      if (topRight > topLeft) {\n        const defaultOffset = isShort(rightMiddle) ? leftMiddle : leftMiddle - 2;\n        leftOffset = isShort(leftMiddle) ? leftMiddle - 1 : defaultOffset;\n      } else {\n        const defaultOffset = isShort(leftMiddle) ? 1 : 2;\n        leftOffset = isShort(rightMiddle) ? defaultOffset : leftMiddle - 2;\n      }\n      moves = [...rightMoves.slice(0, rightOffset), ...leftMoves.slice(leftOffset)];\n      coords = [...rightCoords.slice(0, rightOffset), ...leftCoords.slice(leftOffset)];\n    }\n    const middle = moves.indexOf(\"L\");\n    const subMoves = moves.slice(0, middle);\n    const subCoords = coords.slice(0, middle);\n    return subMoves.map((m, i) => ({\n      command: m,\n      coords: subCoords[i].split(\",\")\n    }));\n  };\n\n  // eslint-disable-next-line max-statements\n  const getBottomPath = () => {\n    const {\n      bottomRight,\n      bottomLeft\n    } = cornerRadius;\n    const arcLength = r1 * Math.abs(end - start);\n    const {\n      rightMoves,\n      rightCoords,\n      rightMiddle,\n      leftMoves,\n      leftCoords,\n      leftMiddle\n    } = getPathData(\"bottom\");\n    let moves;\n    let coords;\n    if (bottomRight === bottomLeft || arcLength < 2 * bottomRight + 2 * bottomLeft) {\n      moves = bottomRight > bottomLeft ? rightMoves : leftMoves;\n      coords = bottomRight > bottomLeft ? rightCoords : leftCoords;\n    } else {\n      // eslint-disable-next-line no-magic-numbers\n      const isShort = (m, middle) => m.length - middle < 4;\n      const shortPath = bottomRight > bottomLeft ? isShort(rightMoves, rightMiddle) : isShort(leftMoves, leftMiddle);\n      // eslint-disable-next-line no-magic-numbers\n      const rightOffset = shortPath ? -1 : -3;\n      moves = [...leftMoves.slice(0, leftMiddle + 2), ...rightMoves.slice(rightOffset)];\n      coords = [...leftCoords.slice(0, leftMiddle + 2), ...rightCoords.slice(rightOffset)];\n    }\n    const middle = moves.indexOf(\"L\");\n    const subMoves = moves.slice(middle, -1);\n    const subCoords = coords.slice(middle, -1);\n    return subMoves.map((m, i) => ({\n      command: m,\n      coords: subCoords[i].split(\",\")\n    }));\n  };\n  const topPath = getTopPath();\n  const bottomPath = getBottomPath();\n  const moves = [...topPath, ...bottomPath];\n  const path = moves.reduce((memo, move) => `${memo}${move.command} ${move.coords.join()}`, \"\");\n  return `${path} z`;\n};\nexport const getBarPath = (props, width, cornerRadius) => {\n  if (props.getPath) {\n    return getCustomBarPath(props, width);\n  }\n  return props.horizontal ? getHorizontalBarPath(props, width, cornerRadius) : getVerticalBarPath(props, width, cornerRadius);\n};\nexport const getPolarBarPath = (props, cornerRadius) => {\n  // TODO Radial bars\n  return getVerticalPolarBarPath(props, cornerRadius);\n};","map":{"version":3,"names":["d3Shape","circle","point","getPosition","props","width","x","x0","y","y0","horizontal","alignment","size","sign","x1","y1","getAngle","index","data","scale","_x1","undefined","getAngularWidth","range","r","Math","max","angularRange","abs","PI","transformAngle","angle","getCustomBarPath","getPath","propsWithCalculatedValues","getStartAngle","currentAngle","previousAngle","length","getEndAngle","lastAngle","nextAngle","mapPointsToPath","coords","cornerRadius","direction","topLeftPath","topLeft","topRightPath","topRight","bottomLeftPath","bottomLeft","bottomRightPath","bottomRight","commands","path","reduce","acc","command","i","getVerticalBarPoints","position","cr","getHalfPoints","side","isLeft","signL","bottomPoint","bottomMiddlePoint","topMiddlePoint","topPoint","hasIntersection","topCenter","topCircle","bottomCenter","bottomCircle","circleIntersection","intersection","hasArcIntersection","arcIntersection","hasBottomLineTopArcIntersection","newX","solveX","points","reverse","concat","getHorizontalBarPoints","isTop","leftPoint","leftMiddlePoint","rightMiddlePoint","rightPoint","leftCenter","leftCircle","rightCenter","rightCircle","hasLeftLineRightArcIntersection","newY","solveY","topPoints","bottomPoints","getVerticalBarPath","getHorizontalBarPath","getVerticalPolarBarPath","datum","style","r1","_y0","r2","_y1","_y","_x","start","end","Number","edge","pathFunction","arc","innerRadius","outerRadius","startAngle","endAngle","getPathData","rightPath","rightMoves","match","rightCoords","split","slice","rightMiddle","indexOf","leftPath","leftMoves","leftCoords","leftMiddle","getTopPath","arcLength","moves","isShort","middle","rightOffset","leftOffset","defaultOffset","subMoves","subCoords","map","m","getBottomPath","shortPath","topPath","bottomPath","memo","move","join","getBarPath","getPolarBarPath"],"sources":["/Users/anjalichaturvedi/GitHub/brew-bridge-dashboard/website/node_modules/victory-bar/es/path-helper-methods.js"],"sourcesContent":["import * as d3Shape from \"victory-vendor/d3-shape\";\nimport { circle, point } from \"./geometry-helper-methods\";\nconst getPosition = (props, width) => {\n  const {\n    x,\n    x0,\n    y,\n    y0,\n    horizontal\n  } = props;\n  const alignment = props.alignment || \"middle\";\n  const size = alignment === \"middle\" ? width / 2 : width;\n  const sign = horizontal ? -1 : 1;\n  if (horizontal) {\n    return {\n      x0,\n      x1: x,\n      y0: alignment === \"start\" ? y : y - sign * size,\n      y1: alignment === \"end\" ? y : y + sign * size\n    };\n  }\n  return {\n    x0: alignment === \"start\" ? x : x - sign * size,\n    x1: alignment === \"end\" ? x : x + sign * size,\n    y0,\n    y1: y\n  };\n};\nconst getAngle = (props, index) => {\n  const {\n    data,\n    scale\n  } = props;\n  const x = data[index]._x1 === undefined ? \"_x\" : \"_x1\";\n  return scale.x(data[index][x]);\n};\nconst getAngularWidth = (props, width) => {\n  const {\n    scale\n  } = props;\n  const range = scale.y.range();\n  const r = Math.max(...range);\n  const angularRange = Math.abs(scale.x.range()[1] - scale.x.range()[0]);\n  return width / (2 * Math.PI * r) * angularRange;\n};\nconst transformAngle = angle => {\n  return -1 * angle + Math.PI / 2;\n};\nexport const getCustomBarPath = (props, width) => {\n  const {\n    getPath\n  } = props;\n  if (typeof getPath === \"function\") {\n    const propsWithCalculatedValues = {\n      ...props,\n      ...getPosition(props, width)\n    };\n    return getPath(propsWithCalculatedValues);\n  }\n};\nconst getStartAngle = (props, index) => {\n  const {\n    data,\n    scale,\n    alignment\n  } = props;\n  const currentAngle = getAngle(props, index);\n  const angularRange = Math.abs(scale.x.range()[1] - scale.x.range()[0]);\n  const previousAngle = index === 0 ? getAngle(props, data.length - 1) - Math.PI * 2 : getAngle(props, index - 1);\n  if (index === 0 && angularRange < 2 * Math.PI) {\n    return scale.x.range()[0];\n  } else if (alignment === \"start\" || alignment === \"end\") {\n    return alignment === \"start\" ? previousAngle : currentAngle;\n  }\n  return (currentAngle + previousAngle) / 2;\n};\nconst getEndAngle = (props, index) => {\n  const {\n    data,\n    scale,\n    alignment\n  } = props;\n  const currentAngle = getAngle(props, index);\n  const angularRange = Math.abs(scale.x.range()[1] - scale.x.range()[0]);\n  const lastAngle = scale.x.range()[1] === 2 * Math.PI ? getAngle(props, 0) + Math.PI * 2 : scale.x.range()[1];\n  const nextAngle = index === data.length - 1 ? getAngle(props, 0) + Math.PI * 2 : getAngle(props, index + 1);\n  if (index === data.length - 1 && angularRange < 2 * Math.PI) {\n    return lastAngle;\n  } else if (alignment === \"start\" || alignment === \"end\") {\n    return alignment === \"start\" ? currentAngle : nextAngle;\n  }\n  return (currentAngle + nextAngle) / 2;\n};\nconst mapPointsToPath = (coords, cornerRadius, direction) => {\n  const topLeftPath = `${cornerRadius.topLeft} ${cornerRadius.topLeft} ${direction}`;\n  const topRightPath = `${cornerRadius.topRight} ${cornerRadius.topRight} ${direction}`;\n  const bottomLeftPath = `${cornerRadius.bottomLeft} ${cornerRadius.bottomLeft} ${direction}`;\n  const bottomRightPath = `${cornerRadius.bottomRight} ${cornerRadius.bottomRight} ${direction}`;\n  const commands = [\"M\", `A ${bottomLeftPath},`, \"L\", `A ${topLeftPath},`, \"L\", `A ${topRightPath},`, \"L\", `A ${bottomRightPath},`];\n  const path = commands.reduce((acc, command, i) => `${acc}${command} ${coords[i].x}, ${coords[i].y} \\n`, \"\");\n  return `${path} z`;\n};\nconst getVerticalBarPoints = (position, sign, cr) => {\n  const {\n    x0,\n    x1,\n    y0,\n    y1\n  } = position;\n\n  // eslint-disable-next-line max-statements, max-len\n  const getHalfPoints = side => {\n    const isLeft = side === \"Left\";\n    const signL = isLeft ? 1 : -1;\n    const x = isLeft ? x0 : x1;\n    let bottomPoint = {\n      x: x + signL * cr[`bottom${side}`],\n      y: y0\n    };\n    let bottomMiddlePoint = {\n      x,\n      y: y0 - sign * cr[`bottom${side}`]\n    };\n    let topMiddlePoint = {\n      x,\n      y: y1 + sign * cr[`top${side}`]\n    };\n    let topPoint = {\n      x: x + signL * cr[`top${side}`],\n      y: y1\n    };\n    const hasIntersection = sign === 1 ? y0 - cr[`bottom${side}`] < y1 + cr[`top${side}`] : y0 + cr[`bottom${side}`] > y1 - cr[`top${side}`];\n    if (hasIntersection) {\n      const topCenter = point(x + signL * cr[`top${side}`], y1 + sign * cr[`top${side}`]);\n      const topCircle = circle(topCenter, cr[`top${side}`]);\n      const bottomCenter = point(x + signL * cr[`bottom${side}`], y0 - sign * cr[`bottom${side}`]);\n      const bottomCircle = circle(bottomCenter, cr[`bottom${side}`]);\n      const circleIntersection = topCircle.intersection(bottomCircle);\n      const hasArcIntersection = circleIntersection.length > 0;\n      if (hasArcIntersection) {\n        const arcIntersection = circleIntersection[isLeft ? 0 : 1];\n        bottomMiddlePoint = {\n          x: arcIntersection.x,\n          y: arcIntersection.y\n        };\n        topMiddlePoint = {\n          x: arcIntersection.x,\n          y: arcIntersection.y\n        };\n      } else {\n        const hasBottomLineTopArcIntersection = cr[`top${side}`] > cr[`bottom${side}`];\n        if (hasBottomLineTopArcIntersection) {\n          const newX = topCircle.solveX(y0)[isLeft ? 0 : 1];\n          bottomPoint = {\n            x: newX,\n            y: y0\n          };\n          bottomMiddlePoint = {\n            x: newX,\n            y: y0\n          };\n          topMiddlePoint = {\n            x: newX,\n            y: y0\n          };\n        } else {\n          const newX = bottomCircle.solveX(y1)[isLeft ? 0 : 1];\n          bottomMiddlePoint = {\n            x: newX,\n            y: y1\n          };\n          topMiddlePoint = {\n            x: newX,\n            y: y1\n          };\n          topPoint = {\n            x: newX,\n            y: y1\n          };\n        }\n      }\n    }\n    const points = [bottomPoint, bottomMiddlePoint, topMiddlePoint, topPoint];\n    return isLeft ? points : points.reverse();\n  };\n  return getHalfPoints(\"Left\").concat(getHalfPoints(\"Right\"));\n};\nconst getHorizontalBarPoints = (position, sign, cr) => {\n  const {\n    y0,\n    y1\n  } = position;\n  const x0 = position.x0 < position.x1 ? position.x0 : position.x1;\n  const x1 = position.x0 < position.x1 ? position.x1 : position.x0;\n\n  // eslint-disable-next-line max-statements, max-len\n  const getHalfPoints = side => {\n    const isTop = side === \"top\";\n    const signL = isTop ? -1 : 1;\n    const y = isTop ? y1 : y0;\n    let leftPoint = {\n      x: x0,\n      y: y - signL * cr[`${side}Left`]\n    };\n    let leftMiddlePoint = {\n      x: x0 + cr[`${side}Left`],\n      y\n    };\n    let rightMiddlePoint = {\n      x: x1 - cr[`${side}Right`],\n      y\n    };\n    let rightPoint = {\n      x: x1,\n      y: y - signL * cr[`${side}Right`]\n    };\n    const hasIntersection = leftMiddlePoint.x > rightMiddlePoint.x;\n    if (hasIntersection) {\n      const leftCenter = point(x0 + cr[`${side}Left`], y - signL * cr[`${side}Left`]);\n      const leftCircle = circle(leftCenter, cr[`${side}Left`]);\n      const rightCenter = point(x1 - cr[`${side}Right`], y - signL * cr[`${side}Right`]);\n      const rightCircle = circle(rightCenter, cr[`${side}Right`]);\n      const circleIntersection = leftCircle.intersection(rightCircle);\n      const hasArcIntersection = circleIntersection.length > 0;\n      if (hasArcIntersection) {\n        const arcIntersection = circleIntersection[sign > 0 ? 1 : 0];\n        leftMiddlePoint = {\n          x: arcIntersection.x,\n          y: arcIntersection.y\n        };\n        rightMiddlePoint = {\n          x: arcIntersection.x,\n          y: arcIntersection.y\n        };\n      } else {\n        const hasLeftLineRightArcIntersection = cr[`${side}Right`] > cr[`${side}Left`];\n        if (hasLeftLineRightArcIntersection) {\n          const newY = rightCircle.solveY(x0)[isTop ? 0 : 1];\n          leftPoint = {\n            x: x0,\n            y: newY\n          };\n          leftMiddlePoint = {\n            x: x0,\n            y: newY\n          };\n          rightMiddlePoint = {\n            x: x0,\n            y: newY\n          };\n        } else {\n          const newY = leftCircle.solveY(x1)[isTop ? 0 : 1];\n          rightPoint = {\n            x: x1,\n            y: newY\n          };\n          rightMiddlePoint = {\n            x: x1,\n            y: newY\n          };\n          leftMiddlePoint = {\n            x: x1,\n            y: newY\n          };\n        }\n      }\n    }\n    return [leftPoint, leftMiddlePoint, rightMiddlePoint, rightPoint];\n  };\n  const topPoints = getHalfPoints(\"top\");\n  const bottomPoints = getHalfPoints(\"bottom\");\n  return [bottomPoints[1], bottomPoints[0], ...topPoints,\n  // eslint-disable-next-line no-magic-numbers\n  bottomPoints[3], bottomPoints[2]];\n};\n\n// eslint-disable-next-line max-params\nexport const getVerticalBarPath = (props, width, cornerRadius) => {\n  const position = getPosition(props, width);\n  const sign = position.y0 > position.y1 ? 1 : -1;\n  const direction = sign > 0 ? \"0 0 1\" : \"0 0 0\";\n  const points = getVerticalBarPoints(position, sign, cornerRadius);\n  return mapPointsToPath(points, cornerRadius, direction);\n};\n\n// eslint-disable-next-line max-params\nexport const getHorizontalBarPath = (props, width, cornerRadius) => {\n  const position = getPosition(props, width);\n  const sign = position.x0 < position.x1 ? 1 : -1;\n  const direction = \"0 0 1\";\n  const cr = {\n    topRight: sign > 0 ? cornerRadius.topLeft : cornerRadius.bottomLeft,\n    bottomRight: sign > 0 ? cornerRadius.topRight : cornerRadius.bottomRight,\n    bottomLeft: sign > 0 ? cornerRadius.bottomRight : cornerRadius.topRight,\n    topLeft: sign > 0 ? cornerRadius.bottomLeft : cornerRadius.topLeft\n  };\n  const points = getHorizontalBarPoints(position, sign, cr);\n  return mapPointsToPath(points, cr, direction);\n};\nexport const getVerticalPolarBarPath = (props, cornerRadius) => {\n  const {\n    datum,\n    scale,\n    index,\n    alignment,\n    style\n  } = props;\n  const r1 = scale.y(datum._y0 || 0);\n  const r2 = scale.y(datum._y1 !== undefined ? datum._y1 : datum._y);\n  const currentAngle = scale.x(datum._x1 !== undefined ? datum._x1 : datum._x);\n  let start;\n  let end;\n  if (style.width) {\n    const width = getAngularWidth(props, style.width);\n    const size = alignment === \"middle\" ? width / 2 : width;\n    start = alignment === \"start\" ? currentAngle : currentAngle - size;\n    end = alignment === \"end\" ? currentAngle : currentAngle + size;\n  } else {\n    start = getStartAngle(props, Number(index));\n    end = getEndAngle(props, Number(index));\n  }\n  const getPath = edge => {\n    const pathFunction = d3Shape.arc().innerRadius(r1).outerRadius(r2).startAngle(transformAngle(start)).endAngle(transformAngle(end)).cornerRadius(cornerRadius[edge]);\n    return pathFunction();\n  };\n  const getPathData = edge => {\n    const rightPath = getPath(`${edge}Right`);\n    const rightMoves = rightPath.match(/[A-Z]/g) || [];\n    const rightCoords = rightPath.split(/[A-Z]/).slice(1);\n    const rightMiddle = rightMoves.indexOf(\"L\");\n    const leftPath = getPath(`${edge}Left`);\n    const leftMoves = leftPath.match(/[A-Z]/g) || [];\n    const leftCoords = leftPath.split(/[A-Z]/).slice(1);\n    const leftMiddle = leftMoves.indexOf(\"L\");\n    return {\n      rightMoves,\n      rightCoords,\n      rightMiddle,\n      leftMoves,\n      leftCoords,\n      leftMiddle\n    };\n  };\n\n  // eslint-disable-next-line max-statements\n  const getTopPath = () => {\n    const {\n      topRight,\n      topLeft\n    } = cornerRadius;\n    const arcLength = r2 * Math.abs(end - start);\n    const {\n      rightMoves,\n      rightCoords,\n      rightMiddle,\n      leftMoves,\n      leftCoords,\n      leftMiddle\n    } = getPathData(\"top\");\n    let moves;\n    let coords;\n    if (topRight === topLeft || arcLength < 2 * topRight + 2 * topLeft) {\n      moves = topRight > topLeft ? rightMoves : leftMoves;\n      coords = topRight > topLeft ? rightCoords : leftCoords;\n    } else {\n      // eslint-disable-next-line no-magic-numbers\n      const isShort = middle => middle < 3;\n      const rightOffset = topLeft > topRight && isShort(rightMiddle) ? 1 : 2;\n      let leftOffset;\n      if (topRight > topLeft) {\n        const defaultOffset = isShort(rightMiddle) ? leftMiddle : leftMiddle - 2;\n        leftOffset = isShort(leftMiddle) ? leftMiddle - 1 : defaultOffset;\n      } else {\n        const defaultOffset = isShort(leftMiddle) ? 1 : 2;\n        leftOffset = isShort(rightMiddle) ? defaultOffset : leftMiddle - 2;\n      }\n      moves = [...rightMoves.slice(0, rightOffset), ...leftMoves.slice(leftOffset)];\n      coords = [...rightCoords.slice(0, rightOffset), ...leftCoords.slice(leftOffset)];\n    }\n    const middle = moves.indexOf(\"L\");\n    const subMoves = moves.slice(0, middle);\n    const subCoords = coords.slice(0, middle);\n    return subMoves.map((m, i) => ({\n      command: m,\n      coords: subCoords[i].split(\",\")\n    }));\n  };\n\n  // eslint-disable-next-line max-statements\n  const getBottomPath = () => {\n    const {\n      bottomRight,\n      bottomLeft\n    } = cornerRadius;\n    const arcLength = r1 * Math.abs(end - start);\n    const {\n      rightMoves,\n      rightCoords,\n      rightMiddle,\n      leftMoves,\n      leftCoords,\n      leftMiddle\n    } = getPathData(\"bottom\");\n    let moves;\n    let coords;\n    if (bottomRight === bottomLeft || arcLength < 2 * bottomRight + 2 * bottomLeft) {\n      moves = bottomRight > bottomLeft ? rightMoves : leftMoves;\n      coords = bottomRight > bottomLeft ? rightCoords : leftCoords;\n    } else {\n      // eslint-disable-next-line no-magic-numbers\n      const isShort = (m, middle) => m.length - middle < 4;\n      const shortPath = bottomRight > bottomLeft ? isShort(rightMoves, rightMiddle) : isShort(leftMoves, leftMiddle);\n      // eslint-disable-next-line no-magic-numbers\n      const rightOffset = shortPath ? -1 : -3;\n      moves = [...leftMoves.slice(0, leftMiddle + 2), ...rightMoves.slice(rightOffset)];\n      coords = [...leftCoords.slice(0, leftMiddle + 2), ...rightCoords.slice(rightOffset)];\n    }\n    const middle = moves.indexOf(\"L\");\n    const subMoves = moves.slice(middle, -1);\n    const subCoords = coords.slice(middle, -1);\n    return subMoves.map((m, i) => ({\n      command: m,\n      coords: subCoords[i].split(\",\")\n    }));\n  };\n  const topPath = getTopPath();\n  const bottomPath = getBottomPath();\n  const moves = [...topPath, ...bottomPath];\n  const path = moves.reduce((memo, move) => `${memo}${move.command} ${move.coords.join()}`, \"\");\n  return `${path} z`;\n};\nexport const getBarPath = (props, width, cornerRadius) => {\n  if (props.getPath) {\n    return getCustomBarPath(props, width);\n  }\n  return props.horizontal ? getHorizontalBarPath(props, width, cornerRadius) : getVerticalBarPath(props, width, cornerRadius);\n};\nexport const getPolarBarPath = (props, cornerRadius) => {\n  // TODO Radial bars\n  return getVerticalPolarBarPath(props, cornerRadius);\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
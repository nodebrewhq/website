{"ast":null,"code":"import _isDate from \"lodash/isDate\";\nimport _sortedUniq from \"lodash/sortedUniq\";\nimport _isPlainObject from \"lodash/isPlainObject\";\n/* eslint-disable no-use-before-define */\nimport React from \"react\";\nimport * as Data from \"./data\";\nimport * as Scale from \"./scale\";\nimport * as Helpers from \"./helpers\";\nimport * as Collection from \"./collection\";\n\n// Private Methods\n\nfunction cleanDomain(domain, props, axis) {\n  const scaleType = Scale.getScaleType(props, axis);\n  if (scaleType !== \"log\") {\n    return domain;\n  }\n  const rules = dom => {\n    const almostZero = dom[0] < 0 || dom[1] < 0 ? -1 / Number.MAX_SAFE_INTEGER : 1 / Number.MAX_SAFE_INTEGER;\n    const domainOne = dom[0] === 0 ? almostZero : dom[0];\n    const domainTwo = dom[1] === 0 ? almostZero : dom[1];\n    return [domainOne, domainTwo];\n  };\n  return rules(domain);\n}\nfunction getDomainPadding(props, axis) {\n  const formatPadding = padding => {\n    return Array.isArray(padding) ? {\n      left: padding[0],\n      right: padding[1]\n    } : {\n      left: padding,\n      right: padding\n    };\n  };\n  return _isPlainObject(props.domainPadding) ? formatPadding(props.domainPadding[axis]) : formatPadding(props.domainPadding);\n}\nfunction getFlatData(dataset, axis) {\n  const axisKey = `_${axis}`;\n  return dataset.flat().map(datum => {\n    return datum[axisKey] && datum[axisKey][1] !== undefined ? datum[axisKey][1] : datum[axisKey];\n  });\n}\nfunction getExtremeFromData(dataset, axis, type) {\n  if (type === void 0) {\n    type = \"min\";\n  }\n  const getExtreme = arr => type === \"max\" ? Math.max(...arr) : Math.min(...arr);\n  const initialValue = type === \"max\" ? -Infinity : Infinity;\n  let containsDate = false;\n  const result = dataset.flat().reduce((memo, datum) => {\n    const current0 = datum[`_${axis}0`] !== undefined ? datum[`_${axis}0`] : datum[`_${axis}`];\n    const current1 = datum[`_${axis}1`] !== undefined ? datum[`_${axis}1`] : datum[`_${axis}`];\n    const current = getExtreme([current0, current1]);\n    containsDate = containsDate || current0 instanceof Date || current1 instanceof Date;\n    return getExtreme([memo, current]);\n  }, initialValue);\n  return containsDate ? new Date(result) : result;\n}\n\n// eslint-disable-next-line max-statements\nfunction padDomain(domain, props, axis) {\n  if (!props.domainPadding) {\n    return domain;\n  }\n  const minDomain = getMinFromProps(props, axis);\n  const maxDomain = getMaxFromProps(props, axis);\n  const padding = getDomainPadding(props, axis);\n  if (!padding.left && !padding.right) {\n    return domain;\n  }\n  const min = Collection.getMinValue(domain);\n  const max = Collection.getMaxValue(domain);\n  const currentAxis = Helpers.getCurrentAxis(axis, props.horizontal);\n  const range = Helpers.getRange(props, currentAxis);\n  const rangeExtent = Math.abs(range[0] - range[1]);\n  const paddedRangeExtent = Math.max(rangeExtent - padding.left - padding.right, 1);\n  const paddedDomainExtent = Math.abs(max.valueOf() - min.valueOf()) / paddedRangeExtent * rangeExtent;\n  const simplePadding = {\n    left: paddedDomainExtent * padding.left / rangeExtent,\n    right: paddedDomainExtent * padding.right / rangeExtent\n  };\n  let paddedDomain = {\n    min: min.valueOf() - simplePadding.left,\n    max: max.valueOf() + simplePadding.right\n  };\n  const singleQuadrantDomainPadding = _isPlainObject(props.singleQuadrantDomainPadding) ? props.singleQuadrantDomainPadding[axis] : props.singleQuadrantDomainPadding;\n  const addsQuadrants = min >= 0 && paddedDomain.min <= 0 || max <= 0 && paddedDomain.max >= 0;\n  const adjust = (val, type) => {\n    const coerce = type === \"min\" && min >= 0 && val <= 0 || type === \"max\" && max <= 0 && val >= 0;\n    return coerce ? 0 : val;\n  };\n  if (addsQuadrants && singleQuadrantDomainPadding !== false) {\n    // Naive initial padding calculation\n    const initialPadding = {\n      // @ts-expect-error `max/min` might be dates\n      left: Math.abs(max - min) * padding.left / rangeExtent,\n      // @ts-expect-error `max/min` might be dates\n      right: Math.abs(max - min) * padding.right / rangeExtent\n    };\n\n    // Adjust the domain by the initial padding\n    const adjustedDomain = {\n      min: adjust(min.valueOf() - initialPadding.left, \"min\"),\n      max: adjust(max.valueOf() + initialPadding.right, \"max\")\n    };\n\n    // re-calculate padding, taking the adjusted domain into account\n    const finalPadding = {\n      left: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.left / rangeExtent,\n      right: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.right / rangeExtent\n    };\n\n    // Adjust the domain by the final padding\n    paddedDomain = {\n      min: adjust(min.valueOf() - finalPadding.left, \"min\"),\n      max: adjust(max.valueOf() + finalPadding.right, \"max\")\n    };\n  }\n\n  // default to minDomain / maxDomain if they exist\n  const finalDomain = {\n    min: minDomain !== undefined ? minDomain : paddedDomain.min,\n    max: maxDomain !== undefined ? maxDomain : paddedDomain.max\n  };\n  return min instanceof Date || max instanceof Date ? getDomainFromMinMax(new Date(finalDomain.min), new Date(finalDomain.max)) : getDomainFromMinMax(finalDomain.min, finalDomain.max);\n}\n\n// Public Methods\n\n/**\n * Returns a getDomain function\n * @param {Function} getDomainFromDataFunction: a function that takes props and axis and\n * returns a domain based on data\n * @param {Function} formatDomainFunction: a function that takes domain, props, and axis and\n * returns a formatted domain\n * @returns {Function} a function that takes props and axis and returns a formatted domain\n */\nexport function createDomainFunction(getDomainFromDataFunction, formatDomainFunction) {\n  const getDomainFromDataFn = Helpers.isFunction(getDomainFromDataFunction) ? getDomainFromDataFunction : getDomainFromData;\n  const formatDomainFn = Helpers.isFunction(formatDomainFunction) ? formatDomainFunction : formatDomain;\n  return (props, axis) => {\n    const propsDomain = getDomainFromProps(props, axis);\n    if (propsDomain) {\n      return formatDomainFn(propsDomain, props, axis);\n    }\n    const categories = Data.getCategories(props, axis);\n    const domain = categories ? getDomainFromCategories(props, axis, categories) : getDomainFromDataFn(props, axis);\n    return domain ? formatDomainFn(domain, props, axis) : undefined;\n  };\n}\n\n/**\n * Returns a formatted domain.\n * @param {Array} domain: a domain in the form of a two element array\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} a domain in the form of a two element array\n */\nexport function formatDomain(domain, props, axis) {\n  return cleanDomain(padDomain(domain, props, axis), props, axis);\n}\n\n/**\n * Returns a domain for a given axis based on props, category, or data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} the domain for the given axis\n */\nexport function getDomain(props, axis) {\n  return createDomainFunction()(props, axis);\n}\n\n/**\n * Returns a domain based on categories if they exist\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @param {Array} categories: an array of categories corresponding to a given axis\n * @returns {Array|undefined} returns a domain from categories or undefined\n */\nexport function getDomainFromCategories(props, axis, categories) {\n  const categoriesArray = categories || Data.getCategories(props, axis);\n  const {\n    polar,\n    startAngle = 0,\n    endAngle = 360\n  } = props;\n  if (!categoriesArray) {\n    return undefined;\n  }\n  const minDomain = getMinFromProps(props, axis);\n  const maxDomain = getMaxFromProps(props, axis);\n  const stringArray = Collection.containsStrings(categoriesArray) ? Data.getStringsFromCategories(props, axis) : [];\n  const stringMap = stringArray.length === 0 ? null : stringArray.reduce((memo, string, index) => {\n    memo[string] = index + 1;\n    return memo;\n  }, {});\n  const categoryValues = stringMap ? categoriesArray.map(value => stringMap[value]) : categoriesArray;\n  const min = minDomain !== undefined ? minDomain : Collection.getMinValue(categoryValues);\n  const max = maxDomain !== undefined ? maxDomain : Collection.getMaxValue(categoryValues);\n  const categoryDomain = getDomainFromMinMax(min, max);\n  return polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(categoryDomain, categoryValues) : categoryDomain;\n}\n\n/**\n * Returns a domain from a dataset for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @param {Array} dataset: an array of data\n * @returns {Array} the domain based on data\n */\nexport function getDomainFromData(props, axis, dataset) {\n  const datasetArray = dataset || Data.getData(props);\n  const {\n    polar,\n    startAngle = 0,\n    endAngle = 360\n  } = props;\n  const minDomain = getMinFromProps(props, axis);\n  const maxDomain = getMaxFromProps(props, axis);\n  if (datasetArray.length < 1) {\n    return minDomain !== undefined && maxDomain !== undefined ? getDomainFromMinMax(minDomain, maxDomain) : undefined;\n  }\n  const min = minDomain !== undefined ? minDomain : getExtremeFromData(datasetArray, axis, \"min\");\n  const max = maxDomain !== undefined ? maxDomain : getExtremeFromData(datasetArray, axis, \"max\");\n  const domain = getDomainFromMinMax(min, max);\n  return polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(domain, getFlatData(datasetArray, axis)) : domain;\n}\n\n/**\n * Returns a domain in the form of a two element array given a min and max value.\n * @param {Number|Date} min: the props object\n * @param {Number|Date} max: the current axis\n * @returns {Array} the minDomain based on props\n */\nexport function getDomainFromMinMax(min, max) {\n  const getSinglePointDomain = val => {\n    // d3-scale does not properly resolve very small differences.\n    const verySmallNumber =\n    // eslint-disable-next-line no-magic-numbers\n    val === 0 ? 2 * Math.pow(10, -10) : Math.pow(10, -10);\n    const verySmallDate = 1;\n    const minVal = val instanceof Date ? new Date(Number(val) - verySmallDate) : Number(val) - verySmallNumber;\n    const maxVal = val instanceof Date ? new Date(Number(val) + verySmallDate) : Number(val) + verySmallNumber;\n    return val === 0 ? [0, maxVal] : [minVal, maxVal];\n  };\n  return Number(min) === Number(max) ? getSinglePointDomain(max) : [min, max];\n}\n\n/**\n * Returns a the domain for a given axis if domain is given in props\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array|undefined} the domain based on props\n */\nexport function getDomainFromProps(props, axis) {\n  const minDomain = getMinFromProps(props, axis);\n  const maxDomain = getMaxFromProps(props, axis);\n  if (_isPlainObject(props.domain) && props.domain[axis]) {\n    return props.domain[axis];\n  } else if (Array.isArray(props.domain)) {\n    return props.domain;\n  } else if (minDomain !== undefined && maxDomain !== undefined) {\n    return getDomainFromMinMax(minDomain, maxDomain);\n  }\n  return undefined;\n}\n\n/**\n * Returns a domain for a given axis. This method forces the domain to include\n * zero unless the domain is explicitly specified in props.\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} the domain for the given axis\n */\nexport function getDomainWithZero(props, axis) {\n  const propsDomain = getDomainFromProps(props, axis);\n  if (propsDomain) {\n    return propsDomain;\n  }\n  const dataset = Data.getData(props);\n  const y0Min = dataset.reduce((min, datum) => datum._y0 < min ? datum._y0 : min, Infinity);\n  const ensureZero = domain => {\n    if (axis === \"x\") {\n      return domain;\n    }\n    const defaultMin = y0Min !== Infinity ? y0Min : 0;\n    const maxDomainProp = getMaxFromProps(props, axis);\n    const minDomainProp = getMinFromProps(props, axis);\n    const max = maxDomainProp !== undefined ? maxDomainProp : Collection.getMaxValue(domain, defaultMin);\n    const min = minDomainProp !== undefined ? minDomainProp : Collection.getMinValue(domain, defaultMin);\n    return getDomainFromMinMax(min, max);\n  };\n  const getDomainFunction = () => {\n    return getDomainFromData(props, axis, dataset);\n  };\n  const formatDomainFunction = domain => {\n    return formatDomain(ensureZero(domain), props, axis);\n  };\n  return createDomainFunction(getDomainFunction, formatDomainFunction)(props, axis);\n}\n\n/**\n * Returns the maxDomain from props if it exists\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Number|Date|undefined} the maxDomain based on props\n */\nexport function getMaxFromProps(props, axis) {\n  if (_isPlainObject(props.maxDomain) && props.maxDomain[axis] !== undefined) {\n    return props.maxDomain[axis];\n  }\n  return typeof props.maxDomain === \"number\" || _isDate(props.maxDomain) ? props.maxDomain : undefined;\n}\n\n/**\n * Returns the minDomain from props if it exists\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Number|Date|undefined} the minDomain based on props\n */\nexport function getMinFromProps(props, axis) {\n  if (_isPlainObject(props.minDomain) && props.minDomain[axis] !== undefined) {\n    return props.minDomain[axis];\n  }\n  return typeof props.minDomain === \"number\" || _isDate(props.minDomain) ? props.minDomain : undefined;\n}\n\n/**\n * Returns a symmetrically padded domain for polar charts\n * @param {Array} domain: the original domain\n * @param {Array} values: a flat array of values corresponding to either tickValues, or data values\n * for a given dimension i.e. only x values.\n * @returns {Array} the symmetric domain\n */\nexport function getSymmetricDomain(domain, values) {\n  const processedData = _sortedUniq(values.sort((a, b) => a - b));\n  const step = processedData[1] - processedData[0];\n  return [domain[0], domain[1] + step];\n}\n\n/**\n * Checks whether a given component can be used to calculate domain\n * @param {Component} component: a React component instance\n * @returns {Boolean} Returns true if the given component has a role included in the whitelist\n */\nexport function isDomainComponent(component) {\n  const getRole = child => {\n    return child && child.type ? child.type.role : \"\";\n  };\n  let role = getRole(component);\n  if (role === \"portal\") {\n    const children = React.Children.toArray(component.props.children);\n    role = children.length ? getRole(children[0]) : \"\";\n  }\n  const whitelist = [\"area\", \"axis\", \"bar\", \"boxplot\", \"candlestick\", \"errorbar\", \"group\", \"histogram\", \"line\", \"pie\", \"scatter\", \"stack\", \"voronoi\"];\n  return whitelist.includes(role);\n}","map":{"version":3,"names":["_isDate","_sortedUniq","_isPlainObject","React","Data","Scale","Helpers","Collection","cleanDomain","domain","props","axis","scaleType","getScaleType","rules","dom","almostZero","Number","MAX_SAFE_INTEGER","domainOne","domainTwo","getDomainPadding","formatPadding","padding","Array","isArray","left","right","domainPadding","getFlatData","dataset","axisKey","flat","map","datum","undefined","getExtremeFromData","type","getExtreme","arr","Math","max","min","initialValue","Infinity","containsDate","result","reduce","memo","current0","current1","current","Date","padDomain","minDomain","getMinFromProps","maxDomain","getMaxFromProps","getMinValue","getMaxValue","currentAxis","getCurrentAxis","horizontal","range","getRange","rangeExtent","abs","paddedRangeExtent","paddedDomainExtent","valueOf","simplePadding","paddedDomain","singleQuadrantDomainPadding","addsQuadrants","adjust","val","coerce","initialPadding","adjustedDomain","finalPadding","finalDomain","getDomainFromMinMax","createDomainFunction","getDomainFromDataFunction","formatDomainFunction","getDomainFromDataFn","isFunction","getDomainFromData","formatDomainFn","formatDomain","propsDomain","getDomainFromProps","categories","getCategories","getDomainFromCategories","getDomain","categoriesArray","polar","startAngle","endAngle","stringArray","containsStrings","getStringsFromCategories","stringMap","length","string","index","categoryValues","value","categoryDomain","getSymmetricDomain","datasetArray","getData","getSinglePointDomain","verySmallNumber","pow","verySmallDate","minVal","maxVal","getDomainWithZero","y0Min","_y0","ensureZero","defaultMin","maxDomainProp","minDomainProp","getDomainFunction","values","processedData","sort","a","b","step","isDomainComponent","component","getRole","child","role","children","Children","toArray","whitelist","includes"],"sources":["/Users/anjalichaturvedi/GitHub/brew-bridge-dashboard/website/node_modules/victory-core/es/victory-util/domain.js"],"sourcesContent":["import _isDate from \"lodash/isDate\";\nimport _sortedUniq from \"lodash/sortedUniq\";\nimport _isPlainObject from \"lodash/isPlainObject\";\n/* eslint-disable no-use-before-define */\nimport React from \"react\";\nimport * as Data from \"./data\";\nimport * as Scale from \"./scale\";\nimport * as Helpers from \"./helpers\";\nimport * as Collection from \"./collection\";\n\n// Private Methods\n\nfunction cleanDomain(domain, props, axis) {\n  const scaleType = Scale.getScaleType(props, axis);\n  if (scaleType !== \"log\") {\n    return domain;\n  }\n  const rules = dom => {\n    const almostZero = dom[0] < 0 || dom[1] < 0 ? -1 / Number.MAX_SAFE_INTEGER : 1 / Number.MAX_SAFE_INTEGER;\n    const domainOne = dom[0] === 0 ? almostZero : dom[0];\n    const domainTwo = dom[1] === 0 ? almostZero : dom[1];\n    return [domainOne, domainTwo];\n  };\n  return rules(domain);\n}\nfunction getDomainPadding(props, axis) {\n  const formatPadding = padding => {\n    return Array.isArray(padding) ? {\n      left: padding[0],\n      right: padding[1]\n    } : {\n      left: padding,\n      right: padding\n    };\n  };\n  return _isPlainObject(props.domainPadding) ? formatPadding(props.domainPadding[axis]) : formatPadding(props.domainPadding);\n}\nfunction getFlatData(dataset, axis) {\n  const axisKey = `_${axis}`;\n  return dataset.flat().map(datum => {\n    return datum[axisKey] && datum[axisKey][1] !== undefined ? datum[axisKey][1] : datum[axisKey];\n  });\n}\nfunction getExtremeFromData(dataset, axis, type) {\n  if (type === void 0) {\n    type = \"min\";\n  }\n  const getExtreme = arr => type === \"max\" ? Math.max(...arr) : Math.min(...arr);\n  const initialValue = type === \"max\" ? -Infinity : Infinity;\n  let containsDate = false;\n  const result = dataset.flat().reduce((memo, datum) => {\n    const current0 = datum[`_${axis}0`] !== undefined ? datum[`_${axis}0`] : datum[`_${axis}`];\n    const current1 = datum[`_${axis}1`] !== undefined ? datum[`_${axis}1`] : datum[`_${axis}`];\n    const current = getExtreme([current0, current1]);\n    containsDate = containsDate || current0 instanceof Date || current1 instanceof Date;\n    return getExtreme([memo, current]);\n  }, initialValue);\n  return containsDate ? new Date(result) : result;\n}\n\n// eslint-disable-next-line max-statements\nfunction padDomain(domain, props, axis) {\n  if (!props.domainPadding) {\n    return domain;\n  }\n  const minDomain = getMinFromProps(props, axis);\n  const maxDomain = getMaxFromProps(props, axis);\n  const padding = getDomainPadding(props, axis);\n  if (!padding.left && !padding.right) {\n    return domain;\n  }\n  const min = Collection.getMinValue(domain);\n  const max = Collection.getMaxValue(domain);\n  const currentAxis = Helpers.getCurrentAxis(axis, props.horizontal);\n  const range = Helpers.getRange(props, currentAxis);\n  const rangeExtent = Math.abs(range[0] - range[1]);\n  const paddedRangeExtent = Math.max(rangeExtent - padding.left - padding.right, 1);\n  const paddedDomainExtent = Math.abs(max.valueOf() - min.valueOf()) / paddedRangeExtent * rangeExtent;\n  const simplePadding = {\n    left: paddedDomainExtent * padding.left / rangeExtent,\n    right: paddedDomainExtent * padding.right / rangeExtent\n  };\n  let paddedDomain = {\n    min: min.valueOf() - simplePadding.left,\n    max: max.valueOf() + simplePadding.right\n  };\n  const singleQuadrantDomainPadding = _isPlainObject(props.singleQuadrantDomainPadding) ? props.singleQuadrantDomainPadding[axis] : props.singleQuadrantDomainPadding;\n  const addsQuadrants = min >= 0 && paddedDomain.min <= 0 || max <= 0 && paddedDomain.max >= 0;\n  const adjust = (val, type) => {\n    const coerce = type === \"min\" && min >= 0 && val <= 0 || type === \"max\" && max <= 0 && val >= 0;\n    return coerce ? 0 : val;\n  };\n  if (addsQuadrants && singleQuadrantDomainPadding !== false) {\n    // Naive initial padding calculation\n    const initialPadding = {\n      // @ts-expect-error `max/min` might be dates\n      left: Math.abs(max - min) * padding.left / rangeExtent,\n      // @ts-expect-error `max/min` might be dates\n      right: Math.abs(max - min) * padding.right / rangeExtent\n    };\n\n    // Adjust the domain by the initial padding\n    const adjustedDomain = {\n      min: adjust(min.valueOf() - initialPadding.left, \"min\"),\n      max: adjust(max.valueOf() + initialPadding.right, \"max\")\n    };\n\n    // re-calculate padding, taking the adjusted domain into account\n    const finalPadding = {\n      left: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.left / rangeExtent,\n      right: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.right / rangeExtent\n    };\n\n    // Adjust the domain by the final padding\n    paddedDomain = {\n      min: adjust(min.valueOf() - finalPadding.left, \"min\"),\n      max: adjust(max.valueOf() + finalPadding.right, \"max\")\n    };\n  }\n\n  // default to minDomain / maxDomain if they exist\n  const finalDomain = {\n    min: minDomain !== undefined ? minDomain : paddedDomain.min,\n    max: maxDomain !== undefined ? maxDomain : paddedDomain.max\n  };\n  return min instanceof Date || max instanceof Date ? getDomainFromMinMax(new Date(finalDomain.min), new Date(finalDomain.max)) : getDomainFromMinMax(finalDomain.min, finalDomain.max);\n}\n\n// Public Methods\n\n/**\n * Returns a getDomain function\n * @param {Function} getDomainFromDataFunction: a function that takes props and axis and\n * returns a domain based on data\n * @param {Function} formatDomainFunction: a function that takes domain, props, and axis and\n * returns a formatted domain\n * @returns {Function} a function that takes props and axis and returns a formatted domain\n */\nexport function createDomainFunction(getDomainFromDataFunction, formatDomainFunction) {\n  const getDomainFromDataFn = Helpers.isFunction(getDomainFromDataFunction) ? getDomainFromDataFunction : getDomainFromData;\n  const formatDomainFn = Helpers.isFunction(formatDomainFunction) ? formatDomainFunction : formatDomain;\n  return (props, axis) => {\n    const propsDomain = getDomainFromProps(props, axis);\n    if (propsDomain) {\n      return formatDomainFn(propsDomain, props, axis);\n    }\n    const categories = Data.getCategories(props, axis);\n    const domain = categories ? getDomainFromCategories(props, axis, categories) : getDomainFromDataFn(props, axis);\n    return domain ? formatDomainFn(domain, props, axis) : undefined;\n  };\n}\n\n/**\n * Returns a formatted domain.\n * @param {Array} domain: a domain in the form of a two element array\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} a domain in the form of a two element array\n */\nexport function formatDomain(domain, props, axis) {\n  return cleanDomain(padDomain(domain, props, axis), props, axis);\n}\n\n/**\n * Returns a domain for a given axis based on props, category, or data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} the domain for the given axis\n */\nexport function getDomain(props, axis) {\n  return createDomainFunction()(props, axis);\n}\n\n/**\n * Returns a domain based on categories if they exist\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @param {Array} categories: an array of categories corresponding to a given axis\n * @returns {Array|undefined} returns a domain from categories or undefined\n */\nexport function getDomainFromCategories(props, axis, categories) {\n  const categoriesArray = categories || Data.getCategories(props, axis);\n  const {\n    polar,\n    startAngle = 0,\n    endAngle = 360\n  } = props;\n  if (!categoriesArray) {\n    return undefined;\n  }\n  const minDomain = getMinFromProps(props, axis);\n  const maxDomain = getMaxFromProps(props, axis);\n  const stringArray = Collection.containsStrings(categoriesArray) ? Data.getStringsFromCategories(props, axis) : [];\n  const stringMap = stringArray.length === 0 ? null : stringArray.reduce((memo, string, index) => {\n    memo[string] = index + 1;\n    return memo;\n  }, {});\n  const categoryValues = stringMap ? categoriesArray.map(value => stringMap[value]) : categoriesArray;\n  const min = minDomain !== undefined ? minDomain : Collection.getMinValue(categoryValues);\n  const max = maxDomain !== undefined ? maxDomain : Collection.getMaxValue(categoryValues);\n  const categoryDomain = getDomainFromMinMax(min, max);\n  return polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(categoryDomain, categoryValues) : categoryDomain;\n}\n\n/**\n * Returns a domain from a dataset for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @param {Array} dataset: an array of data\n * @returns {Array} the domain based on data\n */\nexport function getDomainFromData(props, axis, dataset) {\n  const datasetArray = dataset || Data.getData(props);\n  const {\n    polar,\n    startAngle = 0,\n    endAngle = 360\n  } = props;\n  const minDomain = getMinFromProps(props, axis);\n  const maxDomain = getMaxFromProps(props, axis);\n  if (datasetArray.length < 1) {\n    return minDomain !== undefined && maxDomain !== undefined ? getDomainFromMinMax(minDomain, maxDomain) : undefined;\n  }\n  const min = minDomain !== undefined ? minDomain : getExtremeFromData(datasetArray, axis, \"min\");\n  const max = maxDomain !== undefined ? maxDomain : getExtremeFromData(datasetArray, axis, \"max\");\n  const domain = getDomainFromMinMax(min, max);\n  return polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(domain, getFlatData(datasetArray, axis)) : domain;\n}\n\n/**\n * Returns a domain in the form of a two element array given a min and max value.\n * @param {Number|Date} min: the props object\n * @param {Number|Date} max: the current axis\n * @returns {Array} the minDomain based on props\n */\nexport function getDomainFromMinMax(min, max) {\n  const getSinglePointDomain = val => {\n    // d3-scale does not properly resolve very small differences.\n    const verySmallNumber =\n    // eslint-disable-next-line no-magic-numbers\n    val === 0 ? 2 * Math.pow(10, -10) : Math.pow(10, -10);\n    const verySmallDate = 1;\n    const minVal = val instanceof Date ? new Date(Number(val) - verySmallDate) : Number(val) - verySmallNumber;\n    const maxVal = val instanceof Date ? new Date(Number(val) + verySmallDate) : Number(val) + verySmallNumber;\n    return val === 0 ? [0, maxVal] : [minVal, maxVal];\n  };\n  return Number(min) === Number(max) ? getSinglePointDomain(max) : [min, max];\n}\n\n/**\n * Returns a the domain for a given axis if domain is given in props\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array|undefined} the domain based on props\n */\nexport function getDomainFromProps(props, axis) {\n  const minDomain = getMinFromProps(props, axis);\n  const maxDomain = getMaxFromProps(props, axis);\n  if (_isPlainObject(props.domain) && props.domain[axis]) {\n    return props.domain[axis];\n  } else if (Array.isArray(props.domain)) {\n    return props.domain;\n  } else if (minDomain !== undefined && maxDomain !== undefined) {\n    return getDomainFromMinMax(minDomain, maxDomain);\n  }\n  return undefined;\n}\n\n/**\n * Returns a domain for a given axis. This method forces the domain to include\n * zero unless the domain is explicitly specified in props.\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} the domain for the given axis\n */\nexport function getDomainWithZero(props, axis) {\n  const propsDomain = getDomainFromProps(props, axis);\n  if (propsDomain) {\n    return propsDomain;\n  }\n  const dataset = Data.getData(props);\n  const y0Min = dataset.reduce((min, datum) => datum._y0 < min ? datum._y0 : min, Infinity);\n  const ensureZero = domain => {\n    if (axis === \"x\") {\n      return domain;\n    }\n    const defaultMin = y0Min !== Infinity ? y0Min : 0;\n    const maxDomainProp = getMaxFromProps(props, axis);\n    const minDomainProp = getMinFromProps(props, axis);\n    const max = maxDomainProp !== undefined ? maxDomainProp : Collection.getMaxValue(domain, defaultMin);\n    const min = minDomainProp !== undefined ? minDomainProp : Collection.getMinValue(domain, defaultMin);\n    return getDomainFromMinMax(min, max);\n  };\n  const getDomainFunction = () => {\n    return getDomainFromData(props, axis, dataset);\n  };\n  const formatDomainFunction = domain => {\n    return formatDomain(ensureZero(domain), props, axis);\n  };\n  return createDomainFunction(getDomainFunction, formatDomainFunction)(props, axis);\n}\n\n/**\n * Returns the maxDomain from props if it exists\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Number|Date|undefined} the maxDomain based on props\n */\nexport function getMaxFromProps(props, axis) {\n  if (_isPlainObject(props.maxDomain) && props.maxDomain[axis] !== undefined) {\n    return props.maxDomain[axis];\n  }\n  return typeof props.maxDomain === \"number\" || _isDate(props.maxDomain) ? props.maxDomain : undefined;\n}\n\n/**\n * Returns the minDomain from props if it exists\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Number|Date|undefined} the minDomain based on props\n */\nexport function getMinFromProps(props, axis) {\n  if (_isPlainObject(props.minDomain) && props.minDomain[axis] !== undefined) {\n    return props.minDomain[axis];\n  }\n  return typeof props.minDomain === \"number\" || _isDate(props.minDomain) ? props.minDomain : undefined;\n}\n\n/**\n * Returns a symmetrically padded domain for polar charts\n * @param {Array} domain: the original domain\n * @param {Array} values: a flat array of values corresponding to either tickValues, or data values\n * for a given dimension i.e. only x values.\n * @returns {Array} the symmetric domain\n */\nexport function getSymmetricDomain(domain, values) {\n  const processedData = _sortedUniq(values.sort((a, b) => a - b));\n  const step = processedData[1] - processedData[0];\n  return [domain[0], domain[1] + step];\n}\n\n/**\n * Checks whether a given component can be used to calculate domain\n * @param {Component} component: a React component instance\n * @returns {Boolean} Returns true if the given component has a role included in the whitelist\n */\nexport function isDomainComponent(component) {\n  const getRole = child => {\n    return child && child.type ? child.type.role : \"\";\n  };\n  let role = getRole(component);\n  if (role === \"portal\") {\n    const children = React.Children.toArray(component.props.children);\n    role = children.length ? getRole(children[0]) : \"\";\n  }\n  const whitelist = [\"area\", \"axis\", \"bar\", \"boxplot\", \"candlestick\", \"errorbar\", \"group\", \"histogram\", \"line\", \"pie\", \"scatter\", \"stack\", \"voronoi\"];\n  return whitelist.includes(role);\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
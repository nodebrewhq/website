{"ast":null,"code":"import _isEmpty from \"lodash/isEmpty\";\nimport _flow from \"lodash/flow\";\nimport _forOwn from \"lodash/forOwn\";\nimport _groupBy from \"lodash/groupBy\";\nimport _toPairs from \"lodash/toPairs\";\nimport { Helpers, VictoryContainer, Log } from \"victory-core\";\nimport { voronoiContainerMixin } from \"victory-voronoi-container\";\nimport { zoomContainerMixin } from \"victory-zoom-container\";\nimport { selectionContainerMixin } from \"victory-selection-container\";\nimport { brushContainerMixin } from \"victory-brush-container\";\nimport { cursorContainerMixin } from \"victory-cursor-container\";\nfunction ensureArray(thing) {\n  if (!thing) {\n    return [];\n  } else if (!Array.isArray(thing)) {\n    return [thing];\n  }\n  return thing;\n}\nconst combineEventHandlers = eventHandlersArray => {\n  // takes an array of event handler objects and produces one eventHandlers object\n  // creates a custom combinedHandler() for events with multiple conflicting handlers\n  return eventHandlersArray.reduce((localHandlers, finalHandlers) => {\n    _forOwn(localHandlers, (localHandler, eventName) => {\n      const existingHandler = finalHandlers[eventName];\n      if (existingHandler) {\n        // create new handler for event that concats the existing handler's mutations with new ones\n        finalHandlers[eventName] = function combinedHandler() {\n          // named for debug clarity\n          // sometimes handlers return undefined; use empty array instead, for concat()\n          const existingMutations = ensureArray(existingHandler(...arguments));\n          const localMutations = ensureArray(localHandler(...arguments));\n          return existingMutations.concat(localMutations);\n        };\n      } else {\n        finalHandlers[eventName] = localHandler;\n      }\n    });\n    return finalHandlers;\n  });\n};\nconst combineDefaultEvents = defaultEvents => {\n  // takes a defaultEvents array and returns one equal or lesser length,\n  // by combining any events that have the same target\n  const eventsByTarget = _groupBy(defaultEvents, \"target\");\n  const events = _toPairs(eventsByTarget).map(_ref => {\n    let [target, eventsArray] = _ref;\n    const newEventsArray = eventsArray.filter(Boolean);\n    return _isEmpty(newEventsArray) ? null : {\n      target,\n      eventHandlers: combineEventHandlers(eventsArray.map(event => event.eventHandlers))\n      // note: does not currently handle eventKey or childName\n    };\n  });\n  return events.filter(Boolean);\n};\nexport const combineContainerMixins = (mixins, Container) => {\n  // similar to Object.assign(A, B), this function will decide conflicts in favor mixinB.\n  // this applies to propTypes and defaultProps.\n  // getChildren will call A's getChildren() and pass the resulting children to B's.\n  // defaultEvents attempts to resolve any conflicts between A and B's defaultEvents.\n  const Classes = mixins.map(mixin => mixin(Container));\n  const instances = Classes.map(Class => new Class());\n  const NaiveCombinedContainer = _flow(mixins)(Container);\n  const displayType = Classes.map(Class => {\n    const match = Class.displayName.match(/Victory(.*)Container/);\n    return match[1] || \"\";\n  }).join(\"\");\n  return class VictoryCombinedContainer extends NaiveCombinedContainer {\n    static displayName = `Victory${displayType}Container`;\n    static propTypes = Classes.reduce((propTypes, Class) => ({\n      ...propTypes,\n      ...Class.propTypes\n    }), {});\n    static defaultProps = Classes.reduce((defaultProps, Class) => ({\n      ...defaultProps,\n      ...Class.defaultProps\n    }), {});\n    static defaultEvents(props) {\n      return combineDefaultEvents(Classes.reduce((defaultEvents, Class) => {\n        const events = Helpers.isFunction(Class.defaultEvents) ? Class.defaultEvents(props) : Class.defaultEvents;\n        return [...defaultEvents, ...events];\n      }, []));\n    }\n    getChildren(props) {\n      return instances.reduce((children, instance) => instance.getChildren({\n        ...props,\n        children\n      }), props.children);\n    }\n  };\n};\nconst checkBehaviorName = (behavior, behaviors) => {\n  if (behavior && !behaviors.includes(behavior)) {\n    Log.warn(`\"${behavior}\" is not a valid behavior. Choose from [${behaviors.join(\", \")}].`);\n  }\n};\nexport const makeCreateContainerFunction = (mixinMap, Container) => function (behaviorA, behaviorB) {\n  const behaviors = Object.keys(mixinMap);\n  checkBehaviorName(behaviorA, behaviors);\n  checkBehaviorName(behaviorB, behaviors);\n  if (arguments.length <= 2 ? 0 : arguments.length - 2) {\n    Log.warn(\"too many arguments given to createContainer (maximum accepted: 2).\");\n  }\n  const firstMixins = mixinMap[behaviorA];\n  const secondMixins = mixinMap[behaviorB] || [];\n  if (!firstMixins) {\n    return Container;\n  }\n  return combineContainerMixins([...firstMixins, ...secondMixins], Container);\n};\nexport const createContainer = makeCreateContainerFunction({\n  zoom: [zoomContainerMixin],\n  voronoi: [voronoiContainerMixin],\n  selection: [selectionContainerMixin],\n  cursor: [cursorContainerMixin],\n  brush: [brushContainerMixin]\n}, VictoryContainer);","map":{"version":3,"names":["_isEmpty","_flow","_forOwn","_groupBy","_toPairs","Helpers","VictoryContainer","Log","voronoiContainerMixin","zoomContainerMixin","selectionContainerMixin","brushContainerMixin","cursorContainerMixin","ensureArray","thing","Array","isArray","combineEventHandlers","eventHandlersArray","reduce","localHandlers","finalHandlers","localHandler","eventName","existingHandler","combinedHandler","existingMutations","arguments","localMutations","concat","combineDefaultEvents","defaultEvents","eventsByTarget","events","map","_ref","target","eventsArray","newEventsArray","filter","Boolean","eventHandlers","event","combineContainerMixins","mixins","Container","Classes","mixin","instances","Class","NaiveCombinedContainer","displayType","match","displayName","join","VictoryCombinedContainer","propTypes","defaultProps","props","isFunction","getChildren","children","instance","checkBehaviorName","behavior","behaviors","includes","warn","makeCreateContainerFunction","mixinMap","behaviorA","behaviorB","Object","keys","length","firstMixins","secondMixins","createContainer","zoom","voronoi","selection","cursor","brush"],"sources":["/Users/anjalichaturvedi/GitHub/brew-bridge-dashboard/website/node_modules/victory-create-container/es/create-container.js"],"sourcesContent":["import _isEmpty from \"lodash/isEmpty\";\nimport _flow from \"lodash/flow\";\nimport _forOwn from \"lodash/forOwn\";\nimport _groupBy from \"lodash/groupBy\";\nimport _toPairs from \"lodash/toPairs\";\nimport { Helpers, VictoryContainer, Log } from \"victory-core\";\nimport { voronoiContainerMixin } from \"victory-voronoi-container\";\nimport { zoomContainerMixin } from \"victory-zoom-container\";\nimport { selectionContainerMixin } from \"victory-selection-container\";\nimport { brushContainerMixin } from \"victory-brush-container\";\nimport { cursorContainerMixin } from \"victory-cursor-container\";\nfunction ensureArray(thing) {\n  if (!thing) {\n    return [];\n  } else if (!Array.isArray(thing)) {\n    return [thing];\n  }\n  return thing;\n}\nconst combineEventHandlers = eventHandlersArray => {\n  // takes an array of event handler objects and produces one eventHandlers object\n  // creates a custom combinedHandler() for events with multiple conflicting handlers\n  return eventHandlersArray.reduce((localHandlers, finalHandlers) => {\n    _forOwn(localHandlers, (localHandler, eventName) => {\n      const existingHandler = finalHandlers[eventName];\n      if (existingHandler) {\n        // create new handler for event that concats the existing handler's mutations with new ones\n        finalHandlers[eventName] = function combinedHandler() {\n          // named for debug clarity\n          // sometimes handlers return undefined; use empty array instead, for concat()\n          const existingMutations = ensureArray(existingHandler(...arguments));\n          const localMutations = ensureArray(localHandler(...arguments));\n          return existingMutations.concat(localMutations);\n        };\n      } else {\n        finalHandlers[eventName] = localHandler;\n      }\n    });\n    return finalHandlers;\n  });\n};\nconst combineDefaultEvents = defaultEvents => {\n  // takes a defaultEvents array and returns one equal or lesser length,\n  // by combining any events that have the same target\n  const eventsByTarget = _groupBy(defaultEvents, \"target\");\n  const events = _toPairs(eventsByTarget).map(_ref => {\n    let [target, eventsArray] = _ref;\n    const newEventsArray = eventsArray.filter(Boolean);\n    return _isEmpty(newEventsArray) ? null : {\n      target,\n      eventHandlers: combineEventHandlers(eventsArray.map(event => event.eventHandlers))\n      // note: does not currently handle eventKey or childName\n    };\n  });\n  return events.filter(Boolean);\n};\nexport const combineContainerMixins = (mixins, Container) => {\n  // similar to Object.assign(A, B), this function will decide conflicts in favor mixinB.\n  // this applies to propTypes and defaultProps.\n  // getChildren will call A's getChildren() and pass the resulting children to B's.\n  // defaultEvents attempts to resolve any conflicts between A and B's defaultEvents.\n  const Classes = mixins.map(mixin => mixin(Container));\n  const instances = Classes.map(Class => new Class());\n  const NaiveCombinedContainer = _flow(mixins)(Container);\n  const displayType = Classes.map(Class => {\n    const match = Class.displayName.match(/Victory(.*)Container/);\n    return match[1] || \"\";\n  }).join(\"\");\n  return class VictoryCombinedContainer extends NaiveCombinedContainer {\n    static displayName = `Victory${displayType}Container`;\n    static propTypes = Classes.reduce((propTypes, Class) => ({\n      ...propTypes,\n      ...Class.propTypes\n    }), {});\n    static defaultProps = Classes.reduce((defaultProps, Class) => ({\n      ...defaultProps,\n      ...Class.defaultProps\n    }), {});\n    static defaultEvents(props) {\n      return combineDefaultEvents(Classes.reduce((defaultEvents, Class) => {\n        const events = Helpers.isFunction(Class.defaultEvents) ? Class.defaultEvents(props) : Class.defaultEvents;\n        return [...defaultEvents, ...events];\n      }, []));\n    }\n    getChildren(props) {\n      return instances.reduce((children, instance) => instance.getChildren({\n        ...props,\n        children\n      }), props.children);\n    }\n  };\n};\nconst checkBehaviorName = (behavior, behaviors) => {\n  if (behavior && !behaviors.includes(behavior)) {\n    Log.warn(`\"${behavior}\" is not a valid behavior. Choose from [${behaviors.join(\", \")}].`);\n  }\n};\nexport const makeCreateContainerFunction = (mixinMap, Container) => function (behaviorA, behaviorB) {\n  const behaviors = Object.keys(mixinMap);\n  checkBehaviorName(behaviorA, behaviors);\n  checkBehaviorName(behaviorB, behaviors);\n  if (arguments.length <= 2 ? 0 : arguments.length - 2) {\n    Log.warn(\"too many arguments given to createContainer (maximum accepted: 2).\");\n  }\n  const firstMixins = mixinMap[behaviorA];\n  const secondMixins = mixinMap[behaviorB] || [];\n  if (!firstMixins) {\n    return Container;\n  }\n  return combineContainerMixins([...firstMixins, ...secondMixins], Container);\n};\nexport const createContainer = makeCreateContainerFunction({\n  zoom: [zoomContainerMixin],\n  voronoi: [voronoiContainerMixin],\n  selection: [selectionContainerMixin],\n  cursor: [cursorContainerMixin],\n  brush: [brushContainerMixin]\n}, VictoryContainer);"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _identity from \"lodash/identity\";\nimport _defaults from \"lodash/defaults\";\nimport React from \"react\";\nfunction getDatumKey(datum, idx) {\n  return (datum.key || idx).toString();\n}\nfunction getKeyedData(data) {\n  return data.reduce((keyedData, datum, idx) => {\n    const key = getDatumKey(datum, idx);\n    keyedData[key] = datum;\n    return keyedData;\n  }, {});\n}\nfunction getKeyedDataDifference(a, b) {\n  let hasDifference = false;\n  const difference = Object.keys(a).reduce((_difference, key) => {\n    if (!(key in b)) {\n      hasDifference = true;\n      _difference[key] = true;\n    }\n    return _difference;\n  }, {});\n  return hasDifference && difference;\n}\n\n/**\n * Calculate which data-points exist in oldData and not nextData -\n * these are the `exiting` data-points.  Also calculate which\n * data-points exist in nextData and not oldData - these are the\n * `entering` data-points.\n *\n * @param  {Array} oldData   this.props.data Array\n * @param  {Array} nextData  this.props.data Array\n *\n * @return {Object}          Object with `entering` and `exiting` properties.\n *                           entering[datum.key] will be true if the data is\n *                           entering, and similarly for `exiting`.\n */\nfunction getNodeTransitions(oldData, nextData) {\n  const oldDataKeyed = oldData && getKeyedData(oldData);\n  const nextDataKeyed = nextData && getKeyedData(nextData);\n  return {\n    entering: oldDataKeyed && getKeyedDataDifference(nextDataKeyed, oldDataKeyed),\n    exiting: nextDataKeyed && getKeyedDataDifference(oldDataKeyed, nextDataKeyed)\n  };\n}\nfunction getChildData(child) {\n  if (child.type && child.type.getData) {\n    return child.type.getData(child.props);\n  }\n  return child.props && child.props.data || false;\n}\n\n/**\n * If a parent component has animation enabled, calculate the transitions\n * for any data of any child component that supports data transitions.\n * Data transitions are defined as any two datasets where data nodes exist\n * in the first set and not the second, in the second and not the first,\n * or both.\n *\n * @param  {Children}  oldChildren   this.props.children from old props\n * @param  {Children}  nextChildren  this.props.children from next props\n *\n * @return {Object}                  Object with the following properties:\n *                                    - nodesWillExit\n *                                    - nodesWillEnter\n *                                    - childrenTransitions\n *                                    - nodesShouldEnter\n */\nexport function getInitialTransitionState(oldChildren, nextChildren) {\n  let nodesWillExit = false;\n  let nodesWillEnter = false;\n  const getTransition = (oldChild, newChild) => {\n    if (!newChild || oldChild.type !== newChild.type) {\n      return {};\n    }\n    const {\n      entering,\n      exiting\n    } = getNodeTransitions(getChildData(oldChild), getChildData(newChild)) || {};\n    nodesWillExit = nodesWillExit || !!exiting;\n    nodesWillEnter = nodesWillEnter || !!entering;\n    return {\n      entering: entering || false,\n      exiting: exiting || false\n    };\n  };\n  const getTransitionsFromChildren = (old, next) => {\n    return old.map((child, idx) => {\n      if (child && child.props && child.props.children && next[idx]) {\n        return getTransitionsFromChildren(React.Children.toArray(old[idx].props.children), React.Children.toArray(next[idx].props.children));\n      }\n      // get Transition entering and exiting nodes\n      return getTransition(child, next[idx]);\n    });\n  };\n  const childrenTransitions = getTransitionsFromChildren(React.Children.toArray(oldChildren), React.Children.toArray(nextChildren));\n  return {\n    nodesWillExit,\n    nodesWillEnter,\n    childrenTransitions,\n    // TODO: This may need to be refactored for the following situation.\n    //       The component receives new props, and the data provided\n    //       is a perfect match for the previous data and domain except\n    //       for new nodes. In this case, we wouldn't want a delay before\n    //       the new nodes appear.\n    nodesShouldEnter: false\n  };\n}\nfunction getInitialChildProps(animate, data) {\n  const after = animate.onEnter && animate.onEnter.after ? animate.onEnter.after : _identity;\n  return {\n    data: data.map((datum, idx) => Object.assign({}, datum, after(datum, idx, data)))\n  };\n}\n\n// eslint-disable-next-line max-params\nfunction getChildBeforeLoad(animate, child, data, cb) {\n  const newAnimate = Object.assign({}, animate, {\n    onEnd: cb\n  });\n  if (newAnimate && newAnimate.onLoad && !newAnimate.onLoad.duration) {\n    return {\n      animate: newAnimate,\n      data\n    };\n  }\n  const before = newAnimate.onLoad && newAnimate.onLoad.before ? newAnimate.onLoad.before : _identity;\n  // If nodes need to exit, transform them with the provided onLoad.before function.\n  const newData = data.map((datum, idx) => {\n    return Object.assign({}, datum, before(datum, idx, data));\n  });\n  return {\n    animate: newAnimate,\n    data: newData,\n    clipWidth: 0\n  };\n}\n\n// eslint-disable-next-line max-params\nfunction getChildOnLoad(animate, data, cb) {\n  const newAnimate = Object.assign({}, animate, {\n    onEnd: cb\n  });\n  let newData = data;\n  if (newAnimate && newAnimate.onLoad && !newAnimate.onLoad.duration) {\n    return {\n      animate,\n      data\n    };\n  }\n  const after = animate.onLoad && animate.onLoad.after ? animate.onLoad.after : _identity;\n  // If nodes need to exit, transform them with the provided onLoad.after function.\n  newData = data.map((datum, idx) => {\n    return Object.assign({}, datum, after(datum, idx, data));\n  });\n  return {\n    animate: newAnimate,\n    data: newData\n  };\n}\n\n// eslint-disable-next-line max-params, max-len\nfunction getChildPropsOnExit(animate, child, data, exitingNodes, cb) {\n  // Whether or not _this_ child has exiting nodes, we want the exit-\n  // transition for all children to have the same duration, delay, etc.\n  const onExit = animate && animate.onExit;\n  const newAnimate = Object.assign({}, animate, onExit);\n  let newData = data;\n  if (exitingNodes) {\n    // After the exit transition occurs, trigger the animations for\n    // nodes that are neither exiting nor entering.\n    animate.onEnd = cb;\n    const before = animate.onExit && animate.onExit.before ? animate.onExit.before : _identity;\n    // If nodes need to exit, transform them with the provided onExit.before function.\n    newData = data.map((datum, idx) => {\n      const key = (datum.key || idx).toString();\n      return exitingNodes[key] ? Object.assign({}, datum, before(datum, idx, data)) : datum;\n    });\n  }\n  return {\n    animate: newAnimate,\n    data: newData\n  };\n}\n\n// eslint-disable-next-line max-params,max-len\nfunction getChildPropsBeforeEnter(animate, child, data, enteringNodes, cb) {\n  let newAnimate = animate;\n  let newData = data;\n  if (enteringNodes) {\n    // Perform a normal animation here, except - when it finishes - trigger\n    // the transition for entering nodes.\n    newAnimate = Object.assign({}, animate, {\n      onEnd: cb\n    });\n    const before = animate.onEnter && animate.onEnter.before ? animate.onEnter.before : _identity;\n    // We want the entering nodes to be included in the transition target\n    // domain.  However, we may not want these nodes to be displayed initially,\n    // so perform the `onEnter.before` transformation on each node.\n    newData = data.map((datum, idx) => {\n      const key = (datum.key || idx).toString();\n      return enteringNodes[key] ? Object.assign({}, datum, before(datum, idx, data)) : datum;\n    });\n  }\n  return {\n    animate: newAnimate,\n    data: newData\n  };\n}\n\n// eslint-disable-next-line max-params, max-len\nfunction getChildPropsOnEnter(animate, data, enteringNodes, cb) {\n  // Whether or not _this_ child has entering nodes, we want the entering-\n  // transition for all children to have the same duration, delay, etc.\n  const onEnter = animate && animate.onEnter;\n  const newAnimate = Object.assign({}, animate, onEnter);\n  let newData = data;\n  if (enteringNodes) {\n    // Old nodes have been transitioned to their new values, and the\n    // domain should encompass the nodes that will now enter. So perform\n    // the `onEnter.after` transformation on each node.\n    newAnimate.onEnd = cb;\n    const after = newAnimate.onEnter && newAnimate.onEnter.after ? newAnimate.onEnter.after : _identity;\n    newData = data.map((datum, idx) => {\n      const key = getDatumKey(datum, idx);\n      return enteringNodes[key] ? Object.assign({}, datum, after(datum, idx, data)) : datum;\n    });\n  }\n  return {\n    animate: newAnimate,\n    data: newData\n  };\n}\n\n/**\n * getTransitionPropsFactory - putting the Java in JavaScript.  This will return a\n * function that returns prop transformations for a child, given that child's props\n * and its index in the parent's children array.\n *\n * In particular, this will include an `animate` object that is set appropriately\n * so that each child will be synchronized for each stage of a transition\n * animation.  It will also include a transformed `data` object, where each datum\n * is transformed by `animate.onExit` and `animate.onEnter` `before` and `after`\n * functions.\n *\n * @param  {Object}  props       `this.props` for the parent component.\n * @param  {Object} state        `this.state` for the parent component.\n * @param  {Function} setState    Function that, when called, will `this.setState` on\n *                                 the parent component with the provided object.\n *\n * @return {Function}              Child-prop transformation function.\n */\nexport function getTransitionPropsFactory(props, state, setState) {\n  const nodesWillExit = state && state.nodesWillExit;\n  const nodesWillEnter = state && state.nodesWillEnter;\n  const nodesShouldEnter = state && state.nodesShouldEnter;\n  const nodesShouldLoad = state && state.nodesShouldLoad;\n  const nodesDoneLoad = state && state.nodesDoneLoad;\n  const childrenTransitions = state && state.childrenTransitions || [];\n  const transitionDurations = {\n    enter: props.animate && props.animate.onEnter && props.animate.onEnter.duration,\n    exit: props.animate && props.animate.onExit && props.animate.onExit.duration,\n    load: props.animate && props.animate.onLoad && props.animate.onLoad.duration,\n    move: props.animate && props.animate.duration\n  };\n  const onLoad = (child, data, animate) => {\n    if (nodesShouldLoad) {\n      return getChildOnLoad(animate, data, () => {\n        setState({\n          nodesShouldLoad: false,\n          nodesDoneLoad: true\n        });\n      });\n    }\n    return getChildBeforeLoad(animate, child, data, () => {\n      setState({\n        nodesDoneLoad: true\n      });\n    });\n  };\n\n  // eslint-disable-next-line max-params\n  const onExit = (nodes, child, data, animate) => {\n    return getChildPropsOnExit(animate, child, data, nodes, () => {\n      setState({\n        nodesWillExit: false\n      });\n    });\n  };\n\n  // eslint-disable-next-line max-params\n  const onEnter = (nodes, child, data, animate) => {\n    if (nodesShouldEnter) {\n      return getChildPropsOnEnter(animate, data, nodes, () => {\n        setState({\n          nodesWillEnter: false\n        });\n      });\n    }\n    return getChildPropsBeforeEnter(animate, child, data, nodes, () => {\n      setState({\n        nodesShouldEnter: true\n      });\n    });\n  };\n  const getChildTransitionDuration = function (child, type) {\n    const animate = child.props.animate;\n    if (!child.type) {\n      return {};\n    }\n    const defaultTransitions = child.props && child.props.polar ? child.type.defaultPolarTransitions || child.type.defaultTransitions : child.type.defaultTransitions;\n    if (defaultTransitions) {\n      const animationDuration = animate[type] && animate[type].duration;\n      return animationDuration !== undefined ? animationDuration : defaultTransitions[type] && defaultTransitions[type].duration;\n    }\n    return {};\n  };\n\n  // eslint-disable-next-line max-statements, complexity, max-len\n  return function getTransitionProps(child, index) {\n    const data = getChildData(child) || [];\n    const animate = _defaults({}, props.animate, child.props.animate);\n    const defaultTransitions = child.props.polar ? child.type.defaultPolarTransitions || child.type.defaultTransitions : child.type.defaultTransitions;\n    animate.onExit = _defaults({}, animate.onExit, defaultTransitions && defaultTransitions.onExit);\n    animate.onEnter = _defaults({}, animate.onEnter, defaultTransitions && defaultTransitions.onEnter);\n    animate.onLoad = _defaults({}, animate.onLoad, defaultTransitions && defaultTransitions.onLoad);\n    const childTransitions = childrenTransitions[index] || childrenTransitions[0];\n    if (!nodesDoneLoad) {\n      // should do onLoad animation\n      const load = transitionDurations.load !== undefined ? transitionDurations.load : getChildTransitionDuration(child, \"onLoad\");\n      const animation = {\n        duration: load\n      };\n      return onLoad(child, data, Object.assign({}, animate, animation));\n    } else if (nodesWillExit) {\n      const exitingNodes = childTransitions && childTransitions.exiting;\n      const exit = transitionDurations.exit !== undefined ? transitionDurations.exit : getChildTransitionDuration(child, \"onExit\");\n      // if nodesWillExit, but this child has no exiting nodes, set a delay instead of a duration\n      const animation = exitingNodes ? {\n        duration: exit\n      } : {\n        delay: exit\n      };\n      return onExit(exitingNodes, child, data, Object.assign({}, animate, animation));\n    } else if (nodesWillEnter) {\n      const enteringNodes = childTransitions && childTransitions.entering;\n      const enter = transitionDurations.enter !== undefined ? transitionDurations.enter : getChildTransitionDuration(child, \"onEnter\");\n      const move = transitionDurations.move !== undefined ? transitionDurations.move : child.props.animate && child.props.animate.duration;\n      const animation = {\n        duration: nodesShouldEnter && enteringNodes ? enter : move\n      };\n      return onEnter(enteringNodes, child, data, Object.assign({}, animate, animation));\n    } else if (!state && animate && animate.onExit) {\n      // This is the initial render, and nodes may enter when props change. Because\n      // animation interpolation is determined by old- and next- props, data may need\n      // to be augmented with certain properties.\n      //\n      // For example, it may be desired that exiting nodes go from `opacity: 1` to\n      // `opacity: 0`. Without setting this on a per-datum basis, the interpolation\n      // might go from `opacity: undefined` to `opacity: 0`, which would result in\n      // interpolated `opacity: NaN` values.\n      //\n      return getInitialChildProps(animate, data);\n    }\n    return {\n      animate,\n      data\n    };\n  };\n}","map":{"version":3,"names":["_identity","_defaults","React","getDatumKey","datum","idx","key","toString","getKeyedData","data","reduce","keyedData","getKeyedDataDifference","a","b","hasDifference","difference","Object","keys","_difference","getNodeTransitions","oldData","nextData","oldDataKeyed","nextDataKeyed","entering","exiting","getChildData","child","type","getData","props","getInitialTransitionState","oldChildren","nextChildren","nodesWillExit","nodesWillEnter","getTransition","oldChild","newChild","getTransitionsFromChildren","old","next","map","children","Children","toArray","childrenTransitions","nodesShouldEnter","getInitialChildProps","animate","after","onEnter","assign","getChildBeforeLoad","cb","newAnimate","onEnd","onLoad","duration","before","newData","clipWidth","getChildOnLoad","getChildPropsOnExit","exitingNodes","onExit","getChildPropsBeforeEnter","enteringNodes","getChildPropsOnEnter","getTransitionPropsFactory","state","setState","nodesShouldLoad","nodesDoneLoad","transitionDurations","enter","exit","load","move","nodes","getChildTransitionDuration","defaultTransitions","polar","defaultPolarTransitions","animationDuration","undefined","getTransitionProps","index","childTransitions","animation","delay"],"sources":["/Users/anjalichaturvedi/GitHub/brew-bridge-dashboard/website/node_modules/victory-core/es/victory-util/transitions.js"],"sourcesContent":["import _identity from \"lodash/identity\";\nimport _defaults from \"lodash/defaults\";\nimport React from \"react\";\nfunction getDatumKey(datum, idx) {\n  return (datum.key || idx).toString();\n}\nfunction getKeyedData(data) {\n  return data.reduce((keyedData, datum, idx) => {\n    const key = getDatumKey(datum, idx);\n    keyedData[key] = datum;\n    return keyedData;\n  }, {});\n}\nfunction getKeyedDataDifference(a, b) {\n  let hasDifference = false;\n  const difference = Object.keys(a).reduce((_difference, key) => {\n    if (!(key in b)) {\n      hasDifference = true;\n      _difference[key] = true;\n    }\n    return _difference;\n  }, {});\n  return hasDifference && difference;\n}\n\n/**\n * Calculate which data-points exist in oldData and not nextData -\n * these are the `exiting` data-points.  Also calculate which\n * data-points exist in nextData and not oldData - these are the\n * `entering` data-points.\n *\n * @param  {Array} oldData   this.props.data Array\n * @param  {Array} nextData  this.props.data Array\n *\n * @return {Object}          Object with `entering` and `exiting` properties.\n *                           entering[datum.key] will be true if the data is\n *                           entering, and similarly for `exiting`.\n */\nfunction getNodeTransitions(oldData, nextData) {\n  const oldDataKeyed = oldData && getKeyedData(oldData);\n  const nextDataKeyed = nextData && getKeyedData(nextData);\n  return {\n    entering: oldDataKeyed && getKeyedDataDifference(nextDataKeyed, oldDataKeyed),\n    exiting: nextDataKeyed && getKeyedDataDifference(oldDataKeyed, nextDataKeyed)\n  };\n}\nfunction getChildData(child) {\n  if (child.type && child.type.getData) {\n    return child.type.getData(child.props);\n  }\n  return child.props && child.props.data || false;\n}\n\n/**\n * If a parent component has animation enabled, calculate the transitions\n * for any data of any child component that supports data transitions.\n * Data transitions are defined as any two datasets where data nodes exist\n * in the first set and not the second, in the second and not the first,\n * or both.\n *\n * @param  {Children}  oldChildren   this.props.children from old props\n * @param  {Children}  nextChildren  this.props.children from next props\n *\n * @return {Object}                  Object with the following properties:\n *                                    - nodesWillExit\n *                                    - nodesWillEnter\n *                                    - childrenTransitions\n *                                    - nodesShouldEnter\n */\nexport function getInitialTransitionState(oldChildren, nextChildren) {\n  let nodesWillExit = false;\n  let nodesWillEnter = false;\n  const getTransition = (oldChild, newChild) => {\n    if (!newChild || oldChild.type !== newChild.type) {\n      return {};\n    }\n    const {\n      entering,\n      exiting\n    } = getNodeTransitions(getChildData(oldChild), getChildData(newChild)) || {};\n    nodesWillExit = nodesWillExit || !!exiting;\n    nodesWillEnter = nodesWillEnter || !!entering;\n    return {\n      entering: entering || false,\n      exiting: exiting || false\n    };\n  };\n  const getTransitionsFromChildren = (old, next) => {\n    return old.map((child, idx) => {\n      if (child && child.props && child.props.children && next[idx]) {\n        return getTransitionsFromChildren(React.Children.toArray(old[idx].props.children), React.Children.toArray(next[idx].props.children));\n      }\n      // get Transition entering and exiting nodes\n      return getTransition(child, next[idx]);\n    });\n  };\n  const childrenTransitions = getTransitionsFromChildren(React.Children.toArray(oldChildren), React.Children.toArray(nextChildren));\n  return {\n    nodesWillExit,\n    nodesWillEnter,\n    childrenTransitions,\n    // TODO: This may need to be refactored for the following situation.\n    //       The component receives new props, and the data provided\n    //       is a perfect match for the previous data and domain except\n    //       for new nodes. In this case, we wouldn't want a delay before\n    //       the new nodes appear.\n    nodesShouldEnter: false\n  };\n}\nfunction getInitialChildProps(animate, data) {\n  const after = animate.onEnter && animate.onEnter.after ? animate.onEnter.after : _identity;\n  return {\n    data: data.map((datum, idx) => Object.assign({}, datum, after(datum, idx, data)))\n  };\n}\n\n// eslint-disable-next-line max-params\nfunction getChildBeforeLoad(animate, child, data, cb) {\n  const newAnimate = Object.assign({}, animate, {\n    onEnd: cb\n  });\n  if (newAnimate && newAnimate.onLoad && !newAnimate.onLoad.duration) {\n    return {\n      animate: newAnimate,\n      data\n    };\n  }\n  const before = newAnimate.onLoad && newAnimate.onLoad.before ? newAnimate.onLoad.before : _identity;\n  // If nodes need to exit, transform them with the provided onLoad.before function.\n  const newData = data.map((datum, idx) => {\n    return Object.assign({}, datum, before(datum, idx, data));\n  });\n  return {\n    animate: newAnimate,\n    data: newData,\n    clipWidth: 0\n  };\n}\n\n// eslint-disable-next-line max-params\nfunction getChildOnLoad(animate, data, cb) {\n  const newAnimate = Object.assign({}, animate, {\n    onEnd: cb\n  });\n  let newData = data;\n  if (newAnimate && newAnimate.onLoad && !newAnimate.onLoad.duration) {\n    return {\n      animate,\n      data\n    };\n  }\n  const after = animate.onLoad && animate.onLoad.after ? animate.onLoad.after : _identity;\n  // If nodes need to exit, transform them with the provided onLoad.after function.\n  newData = data.map((datum, idx) => {\n    return Object.assign({}, datum, after(datum, idx, data));\n  });\n  return {\n    animate: newAnimate,\n    data: newData\n  };\n}\n\n// eslint-disable-next-line max-params, max-len\nfunction getChildPropsOnExit(animate, child, data, exitingNodes, cb) {\n  // Whether or not _this_ child has exiting nodes, we want the exit-\n  // transition for all children to have the same duration, delay, etc.\n  const onExit = animate && animate.onExit;\n  const newAnimate = Object.assign({}, animate, onExit);\n  let newData = data;\n  if (exitingNodes) {\n    // After the exit transition occurs, trigger the animations for\n    // nodes that are neither exiting nor entering.\n    animate.onEnd = cb;\n    const before = animate.onExit && animate.onExit.before ? animate.onExit.before : _identity;\n    // If nodes need to exit, transform them with the provided onExit.before function.\n    newData = data.map((datum, idx) => {\n      const key = (datum.key || idx).toString();\n      return exitingNodes[key] ? Object.assign({}, datum, before(datum, idx, data)) : datum;\n    });\n  }\n  return {\n    animate: newAnimate,\n    data: newData\n  };\n}\n\n// eslint-disable-next-line max-params,max-len\nfunction getChildPropsBeforeEnter(animate, child, data, enteringNodes, cb) {\n  let newAnimate = animate;\n  let newData = data;\n  if (enteringNodes) {\n    // Perform a normal animation here, except - when it finishes - trigger\n    // the transition for entering nodes.\n    newAnimate = Object.assign({}, animate, {\n      onEnd: cb\n    });\n    const before = animate.onEnter && animate.onEnter.before ? animate.onEnter.before : _identity;\n    // We want the entering nodes to be included in the transition target\n    // domain.  However, we may not want these nodes to be displayed initially,\n    // so perform the `onEnter.before` transformation on each node.\n    newData = data.map((datum, idx) => {\n      const key = (datum.key || idx).toString();\n      return enteringNodes[key] ? Object.assign({}, datum, before(datum, idx, data)) : datum;\n    });\n  }\n  return {\n    animate: newAnimate,\n    data: newData\n  };\n}\n\n// eslint-disable-next-line max-params, max-len\nfunction getChildPropsOnEnter(animate, data, enteringNodes, cb) {\n  // Whether or not _this_ child has entering nodes, we want the entering-\n  // transition for all children to have the same duration, delay, etc.\n  const onEnter = animate && animate.onEnter;\n  const newAnimate = Object.assign({}, animate, onEnter);\n  let newData = data;\n  if (enteringNodes) {\n    // Old nodes have been transitioned to their new values, and the\n    // domain should encompass the nodes that will now enter. So perform\n    // the `onEnter.after` transformation on each node.\n    newAnimate.onEnd = cb;\n    const after = newAnimate.onEnter && newAnimate.onEnter.after ? newAnimate.onEnter.after : _identity;\n    newData = data.map((datum, idx) => {\n      const key = getDatumKey(datum, idx);\n      return enteringNodes[key] ? Object.assign({}, datum, after(datum, idx, data)) : datum;\n    });\n  }\n  return {\n    animate: newAnimate,\n    data: newData\n  };\n}\n\n/**\n * getTransitionPropsFactory - putting the Java in JavaScript.  This will return a\n * function that returns prop transformations for a child, given that child's props\n * and its index in the parent's children array.\n *\n * In particular, this will include an `animate` object that is set appropriately\n * so that each child will be synchronized for each stage of a transition\n * animation.  It will also include a transformed `data` object, where each datum\n * is transformed by `animate.onExit` and `animate.onEnter` `before` and `after`\n * functions.\n *\n * @param  {Object}  props       `this.props` for the parent component.\n * @param  {Object} state        `this.state` for the parent component.\n * @param  {Function} setState    Function that, when called, will `this.setState` on\n *                                 the parent component with the provided object.\n *\n * @return {Function}              Child-prop transformation function.\n */\nexport function getTransitionPropsFactory(props, state, setState) {\n  const nodesWillExit = state && state.nodesWillExit;\n  const nodesWillEnter = state && state.nodesWillEnter;\n  const nodesShouldEnter = state && state.nodesShouldEnter;\n  const nodesShouldLoad = state && state.nodesShouldLoad;\n  const nodesDoneLoad = state && state.nodesDoneLoad;\n  const childrenTransitions = state && state.childrenTransitions || [];\n  const transitionDurations = {\n    enter: props.animate && props.animate.onEnter && props.animate.onEnter.duration,\n    exit: props.animate && props.animate.onExit && props.animate.onExit.duration,\n    load: props.animate && props.animate.onLoad && props.animate.onLoad.duration,\n    move: props.animate && props.animate.duration\n  };\n  const onLoad = (child, data, animate) => {\n    if (nodesShouldLoad) {\n      return getChildOnLoad(animate, data, () => {\n        setState({\n          nodesShouldLoad: false,\n          nodesDoneLoad: true\n        });\n      });\n    }\n    return getChildBeforeLoad(animate, child, data, () => {\n      setState({\n        nodesDoneLoad: true\n      });\n    });\n  };\n\n  // eslint-disable-next-line max-params\n  const onExit = (nodes, child, data, animate) => {\n    return getChildPropsOnExit(animate, child, data, nodes, () => {\n      setState({\n        nodesWillExit: false\n      });\n    });\n  };\n\n  // eslint-disable-next-line max-params\n  const onEnter = (nodes, child, data, animate) => {\n    if (nodesShouldEnter) {\n      return getChildPropsOnEnter(animate, data, nodes, () => {\n        setState({\n          nodesWillEnter: false\n        });\n      });\n    }\n    return getChildPropsBeforeEnter(animate, child, data, nodes, () => {\n      setState({\n        nodesShouldEnter: true\n      });\n    });\n  };\n  const getChildTransitionDuration = function (child, type) {\n    const animate = child.props.animate;\n    if (!child.type) {\n      return {};\n    }\n    const defaultTransitions = child.props && child.props.polar ? child.type.defaultPolarTransitions || child.type.defaultTransitions : child.type.defaultTransitions;\n    if (defaultTransitions) {\n      const animationDuration = animate[type] && animate[type].duration;\n      return animationDuration !== undefined ? animationDuration : defaultTransitions[type] && defaultTransitions[type].duration;\n    }\n    return {};\n  };\n\n  // eslint-disable-next-line max-statements, complexity, max-len\n  return function getTransitionProps(child, index) {\n    const data = getChildData(child) || [];\n    const animate = _defaults({}, props.animate, child.props.animate);\n    const defaultTransitions = child.props.polar ? child.type.defaultPolarTransitions || child.type.defaultTransitions : child.type.defaultTransitions;\n    animate.onExit = _defaults({}, animate.onExit, defaultTransitions && defaultTransitions.onExit);\n    animate.onEnter = _defaults({}, animate.onEnter, defaultTransitions && defaultTransitions.onEnter);\n    animate.onLoad = _defaults({}, animate.onLoad, defaultTransitions && defaultTransitions.onLoad);\n    const childTransitions = childrenTransitions[index] || childrenTransitions[0];\n    if (!nodesDoneLoad) {\n      // should do onLoad animation\n      const load = transitionDurations.load !== undefined ? transitionDurations.load : getChildTransitionDuration(child, \"onLoad\");\n      const animation = {\n        duration: load\n      };\n      return onLoad(child, data, Object.assign({}, animate, animation));\n    } else if (nodesWillExit) {\n      const exitingNodes = childTransitions && childTransitions.exiting;\n      const exit = transitionDurations.exit !== undefined ? transitionDurations.exit : getChildTransitionDuration(child, \"onExit\");\n      // if nodesWillExit, but this child has no exiting nodes, set a delay instead of a duration\n      const animation = exitingNodes ? {\n        duration: exit\n      } : {\n        delay: exit\n      };\n      return onExit(exitingNodes, child, data, Object.assign({}, animate, animation));\n    } else if (nodesWillEnter) {\n      const enteringNodes = childTransitions && childTransitions.entering;\n      const enter = transitionDurations.enter !== undefined ? transitionDurations.enter : getChildTransitionDuration(child, \"onEnter\");\n      const move = transitionDurations.move !== undefined ? transitionDurations.move : child.props.animate && child.props.animate.duration;\n      const animation = {\n        duration: nodesShouldEnter && enteringNodes ? enter : move\n      };\n      return onEnter(enteringNodes, child, data, Object.assign({}, animate, animation));\n    } else if (!state && animate && animate.onExit) {\n      // This is the initial render, and nodes may enter when props change. Because\n      // animation interpolation is determined by old- and next- props, data may need\n      // to be augmented with certain properties.\n      //\n      // For example, it may be desired that exiting nodes go from `opacity: 1` to\n      // `opacity: 0`. Without setting this on a per-datum basis, the interpolation\n      // might go from `opacity: undefined` to `opacity: 0`, which would result in\n      // interpolated `opacity: NaN` values.\n      //\n      return getInitialChildProps(animate, data);\n    }\n    return {\n      animate,\n      data\n    };\n  };\n}"],"mappings":"AAAA,OAAOA,SAAS,MAAM,iBAAiB;AACvC,OAAOC,SAAS,MAAM,iBAAiB;AACvC,OAAOC,KAAK,MAAM,OAAO;AACzB,SAASC,WAAWA,CAACC,KAAK,EAAEC,GAAG,EAAE;EAC/B,OAAO,CAACD,KAAK,CAACE,GAAG,IAAID,GAAG,EAAEE,QAAQ,CAAC,CAAC;AACtC;AACA,SAASC,YAAYA,CAACC,IAAI,EAAE;EAC1B,OAAOA,IAAI,CAACC,MAAM,CAAC,CAACC,SAAS,EAAEP,KAAK,EAAEC,GAAG,KAAK;IAC5C,MAAMC,GAAG,GAAGH,WAAW,CAACC,KAAK,EAAEC,GAAG,CAAC;IACnCM,SAAS,CAACL,GAAG,CAAC,GAAGF,KAAK;IACtB,OAAOO,SAAS;EAClB,CAAC,EAAE,CAAC,CAAC,CAAC;AACR;AACA,SAASC,sBAAsBA,CAACC,CAAC,EAAEC,CAAC,EAAE;EACpC,IAAIC,aAAa,GAAG,KAAK;EACzB,MAAMC,UAAU,GAAGC,MAAM,CAACC,IAAI,CAACL,CAAC,CAAC,CAACH,MAAM,CAAC,CAACS,WAAW,EAAEb,GAAG,KAAK;IAC7D,IAAI,EAAEA,GAAG,IAAIQ,CAAC,CAAC,EAAE;MACfC,aAAa,GAAG,IAAI;MACpBI,WAAW,CAACb,GAAG,CAAC,GAAG,IAAI;IACzB;IACA,OAAOa,WAAW;EACpB,CAAC,EAAE,CAAC,CAAC,CAAC;EACN,OAAOJ,aAAa,IAAIC,UAAU;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASI,kBAAkBA,CAACC,OAAO,EAAEC,QAAQ,EAAE;EAC7C,MAAMC,YAAY,GAAGF,OAAO,IAAIb,YAAY,CAACa,OAAO,CAAC;EACrD,MAAMG,aAAa,GAAGF,QAAQ,IAAId,YAAY,CAACc,QAAQ,CAAC;EACxD,OAAO;IACLG,QAAQ,EAAEF,YAAY,IAAIX,sBAAsB,CAACY,aAAa,EAAED,YAAY,CAAC;IAC7EG,OAAO,EAAEF,aAAa,IAAIZ,sBAAsB,CAACW,YAAY,EAAEC,aAAa;EAC9E,CAAC;AACH;AACA,SAASG,YAAYA,CAACC,KAAK,EAAE;EAC3B,IAAIA,KAAK,CAACC,IAAI,IAAID,KAAK,CAACC,IAAI,CAACC,OAAO,EAAE;IACpC,OAAOF,KAAK,CAACC,IAAI,CAACC,OAAO,CAACF,KAAK,CAACG,KAAK,CAAC;EACxC;EACA,OAAOH,KAAK,CAACG,KAAK,IAAIH,KAAK,CAACG,KAAK,CAACtB,IAAI,IAAI,KAAK;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASuB,yBAAyBA,CAACC,WAAW,EAAEC,YAAY,EAAE;EACnE,IAAIC,aAAa,GAAG,KAAK;EACzB,IAAIC,cAAc,GAAG,KAAK;EAC1B,MAAMC,aAAa,GAAGA,CAACC,QAAQ,EAAEC,QAAQ,KAAK;IAC5C,IAAI,CAACA,QAAQ,IAAID,QAAQ,CAACT,IAAI,KAAKU,QAAQ,CAACV,IAAI,EAAE;MAChD,OAAO,CAAC,CAAC;IACX;IACA,MAAM;MACJJ,QAAQ;MACRC;IACF,CAAC,GAAGN,kBAAkB,CAACO,YAAY,CAACW,QAAQ,CAAC,EAAEX,YAAY,CAACY,QAAQ,CAAC,CAAC,IAAI,CAAC,CAAC;IAC5EJ,aAAa,GAAGA,aAAa,IAAI,CAAC,CAACT,OAAO;IAC1CU,cAAc,GAAGA,cAAc,IAAI,CAAC,CAACX,QAAQ;IAC7C,OAAO;MACLA,QAAQ,EAAEA,QAAQ,IAAI,KAAK;MAC3BC,OAAO,EAAEA,OAAO,IAAI;IACtB,CAAC;EACH,CAAC;EACD,MAAMc,0BAA0B,GAAGA,CAACC,GAAG,EAAEC,IAAI,KAAK;IAChD,OAAOD,GAAG,CAACE,GAAG,CAAC,CAACf,KAAK,EAAEvB,GAAG,KAAK;MAC7B,IAAIuB,KAAK,IAAIA,KAAK,CAACG,KAAK,IAAIH,KAAK,CAACG,KAAK,CAACa,QAAQ,IAAIF,IAAI,CAACrC,GAAG,CAAC,EAAE;QAC7D,OAAOmC,0BAA0B,CAACtC,KAAK,CAAC2C,QAAQ,CAACC,OAAO,CAACL,GAAG,CAACpC,GAAG,CAAC,CAAC0B,KAAK,CAACa,QAAQ,CAAC,EAAE1C,KAAK,CAAC2C,QAAQ,CAACC,OAAO,CAACJ,IAAI,CAACrC,GAAG,CAAC,CAAC0B,KAAK,CAACa,QAAQ,CAAC,CAAC;MACtI;MACA;MACA,OAAOP,aAAa,CAACT,KAAK,EAAEc,IAAI,CAACrC,GAAG,CAAC,CAAC;IACxC,CAAC,CAAC;EACJ,CAAC;EACD,MAAM0C,mBAAmB,GAAGP,0BAA0B,CAACtC,KAAK,CAAC2C,QAAQ,CAACC,OAAO,CAACb,WAAW,CAAC,EAAE/B,KAAK,CAAC2C,QAAQ,CAACC,OAAO,CAACZ,YAAY,CAAC,CAAC;EACjI,OAAO;IACLC,aAAa;IACbC,cAAc;IACdW,mBAAmB;IACnB;IACA;IACA;IACA;IACA;IACAC,gBAAgB,EAAE;EACpB,CAAC;AACH;AACA,SAASC,oBAAoBA,CAACC,OAAO,EAAEzC,IAAI,EAAE;EAC3C,MAAM0C,KAAK,GAAGD,OAAO,CAACE,OAAO,IAAIF,OAAO,CAACE,OAAO,CAACD,KAAK,GAAGD,OAAO,CAACE,OAAO,CAACD,KAAK,GAAGnD,SAAS;EAC1F,OAAO;IACLS,IAAI,EAAEA,IAAI,CAACkC,GAAG,CAAC,CAACvC,KAAK,EAAEC,GAAG,KAAKY,MAAM,CAACoC,MAAM,CAAC,CAAC,CAAC,EAAEjD,KAAK,EAAE+C,KAAK,CAAC/C,KAAK,EAAEC,GAAG,EAAEI,IAAI,CAAC,CAAC;EAClF,CAAC;AACH;;AAEA;AACA,SAAS6C,kBAAkBA,CAACJ,OAAO,EAAEtB,KAAK,EAAEnB,IAAI,EAAE8C,EAAE,EAAE;EACpD,MAAMC,UAAU,GAAGvC,MAAM,CAACoC,MAAM,CAAC,CAAC,CAAC,EAAEH,OAAO,EAAE;IAC5CO,KAAK,EAAEF;EACT,CAAC,CAAC;EACF,IAAIC,UAAU,IAAIA,UAAU,CAACE,MAAM,IAAI,CAACF,UAAU,CAACE,MAAM,CAACC,QAAQ,EAAE;IAClE,OAAO;MACLT,OAAO,EAAEM,UAAU;MACnB/C;IACF,CAAC;EACH;EACA,MAAMmD,MAAM,GAAGJ,UAAU,CAACE,MAAM,IAAIF,UAAU,CAACE,MAAM,CAACE,MAAM,GAAGJ,UAAU,CAACE,MAAM,CAACE,MAAM,GAAG5D,SAAS;EACnG;EACA,MAAM6D,OAAO,GAAGpD,IAAI,CAACkC,GAAG,CAAC,CAACvC,KAAK,EAAEC,GAAG,KAAK;IACvC,OAAOY,MAAM,CAACoC,MAAM,CAAC,CAAC,CAAC,EAAEjD,KAAK,EAAEwD,MAAM,CAACxD,KAAK,EAAEC,GAAG,EAAEI,IAAI,CAAC,CAAC;EAC3D,CAAC,CAAC;EACF,OAAO;IACLyC,OAAO,EAAEM,UAAU;IACnB/C,IAAI,EAAEoD,OAAO;IACbC,SAAS,EAAE;EACb,CAAC;AACH;;AAEA;AACA,SAASC,cAAcA,CAACb,OAAO,EAAEzC,IAAI,EAAE8C,EAAE,EAAE;EACzC,MAAMC,UAAU,GAAGvC,MAAM,CAACoC,MAAM,CAAC,CAAC,CAAC,EAAEH,OAAO,EAAE;IAC5CO,KAAK,EAAEF;EACT,CAAC,CAAC;EACF,IAAIM,OAAO,GAAGpD,IAAI;EAClB,IAAI+C,UAAU,IAAIA,UAAU,CAACE,MAAM,IAAI,CAACF,UAAU,CAACE,MAAM,CAACC,QAAQ,EAAE;IAClE,OAAO;MACLT,OAAO;MACPzC;IACF,CAAC;EACH;EACA,MAAM0C,KAAK,GAAGD,OAAO,CAACQ,MAAM,IAAIR,OAAO,CAACQ,MAAM,CAACP,KAAK,GAAGD,OAAO,CAACQ,MAAM,CAACP,KAAK,GAAGnD,SAAS;EACvF;EACA6D,OAAO,GAAGpD,IAAI,CAACkC,GAAG,CAAC,CAACvC,KAAK,EAAEC,GAAG,KAAK;IACjC,OAAOY,MAAM,CAACoC,MAAM,CAAC,CAAC,CAAC,EAAEjD,KAAK,EAAE+C,KAAK,CAAC/C,KAAK,EAAEC,GAAG,EAAEI,IAAI,CAAC,CAAC;EAC1D,CAAC,CAAC;EACF,OAAO;IACLyC,OAAO,EAAEM,UAAU;IACnB/C,IAAI,EAAEoD;EACR,CAAC;AACH;;AAEA;AACA,SAASG,mBAAmBA,CAACd,OAAO,EAAEtB,KAAK,EAAEnB,IAAI,EAAEwD,YAAY,EAAEV,EAAE,EAAE;EACnE;EACA;EACA,MAAMW,MAAM,GAAGhB,OAAO,IAAIA,OAAO,CAACgB,MAAM;EACxC,MAAMV,UAAU,GAAGvC,MAAM,CAACoC,MAAM,CAAC,CAAC,CAAC,EAAEH,OAAO,EAAEgB,MAAM,CAAC;EACrD,IAAIL,OAAO,GAAGpD,IAAI;EAClB,IAAIwD,YAAY,EAAE;IAChB;IACA;IACAf,OAAO,CAACO,KAAK,GAAGF,EAAE;IAClB,MAAMK,MAAM,GAAGV,OAAO,CAACgB,MAAM,IAAIhB,OAAO,CAACgB,MAAM,CAACN,MAAM,GAAGV,OAAO,CAACgB,MAAM,CAACN,MAAM,GAAG5D,SAAS;IAC1F;IACA6D,OAAO,GAAGpD,IAAI,CAACkC,GAAG,CAAC,CAACvC,KAAK,EAAEC,GAAG,KAAK;MACjC,MAAMC,GAAG,GAAG,CAACF,KAAK,CAACE,GAAG,IAAID,GAAG,EAAEE,QAAQ,CAAC,CAAC;MACzC,OAAO0D,YAAY,CAAC3D,GAAG,CAAC,GAAGW,MAAM,CAACoC,MAAM,CAAC,CAAC,CAAC,EAAEjD,KAAK,EAAEwD,MAAM,CAACxD,KAAK,EAAEC,GAAG,EAAEI,IAAI,CAAC,CAAC,GAAGL,KAAK;IACvF,CAAC,CAAC;EACJ;EACA,OAAO;IACL8C,OAAO,EAAEM,UAAU;IACnB/C,IAAI,EAAEoD;EACR,CAAC;AACH;;AAEA;AACA,SAASM,wBAAwBA,CAACjB,OAAO,EAAEtB,KAAK,EAAEnB,IAAI,EAAE2D,aAAa,EAAEb,EAAE,EAAE;EACzE,IAAIC,UAAU,GAAGN,OAAO;EACxB,IAAIW,OAAO,GAAGpD,IAAI;EAClB,IAAI2D,aAAa,EAAE;IACjB;IACA;IACAZ,UAAU,GAAGvC,MAAM,CAACoC,MAAM,CAAC,CAAC,CAAC,EAAEH,OAAO,EAAE;MACtCO,KAAK,EAAEF;IACT,CAAC,CAAC;IACF,MAAMK,MAAM,GAAGV,OAAO,CAACE,OAAO,IAAIF,OAAO,CAACE,OAAO,CAACQ,MAAM,GAAGV,OAAO,CAACE,OAAO,CAACQ,MAAM,GAAG5D,SAAS;IAC7F;IACA;IACA;IACA6D,OAAO,GAAGpD,IAAI,CAACkC,GAAG,CAAC,CAACvC,KAAK,EAAEC,GAAG,KAAK;MACjC,MAAMC,GAAG,GAAG,CAACF,KAAK,CAACE,GAAG,IAAID,GAAG,EAAEE,QAAQ,CAAC,CAAC;MACzC,OAAO6D,aAAa,CAAC9D,GAAG,CAAC,GAAGW,MAAM,CAACoC,MAAM,CAAC,CAAC,CAAC,EAAEjD,KAAK,EAAEwD,MAAM,CAACxD,KAAK,EAAEC,GAAG,EAAEI,IAAI,CAAC,CAAC,GAAGL,KAAK;IACxF,CAAC,CAAC;EACJ;EACA,OAAO;IACL8C,OAAO,EAAEM,UAAU;IACnB/C,IAAI,EAAEoD;EACR,CAAC;AACH;;AAEA;AACA,SAASQ,oBAAoBA,CAACnB,OAAO,EAAEzC,IAAI,EAAE2D,aAAa,EAAEb,EAAE,EAAE;EAC9D;EACA;EACA,MAAMH,OAAO,GAAGF,OAAO,IAAIA,OAAO,CAACE,OAAO;EAC1C,MAAMI,UAAU,GAAGvC,MAAM,CAACoC,MAAM,CAAC,CAAC,CAAC,EAAEH,OAAO,EAAEE,OAAO,CAAC;EACtD,IAAIS,OAAO,GAAGpD,IAAI;EAClB,IAAI2D,aAAa,EAAE;IACjB;IACA;IACA;IACAZ,UAAU,CAACC,KAAK,GAAGF,EAAE;IACrB,MAAMJ,KAAK,GAAGK,UAAU,CAACJ,OAAO,IAAII,UAAU,CAACJ,OAAO,CAACD,KAAK,GAAGK,UAAU,CAACJ,OAAO,CAACD,KAAK,GAAGnD,SAAS;IACnG6D,OAAO,GAAGpD,IAAI,CAACkC,GAAG,CAAC,CAACvC,KAAK,EAAEC,GAAG,KAAK;MACjC,MAAMC,GAAG,GAAGH,WAAW,CAACC,KAAK,EAAEC,GAAG,CAAC;MACnC,OAAO+D,aAAa,CAAC9D,GAAG,CAAC,GAAGW,MAAM,CAACoC,MAAM,CAAC,CAAC,CAAC,EAAEjD,KAAK,EAAE+C,KAAK,CAAC/C,KAAK,EAAEC,GAAG,EAAEI,IAAI,CAAC,CAAC,GAAGL,KAAK;IACvF,CAAC,CAAC;EACJ;EACA,OAAO;IACL8C,OAAO,EAAEM,UAAU;IACnB/C,IAAI,EAAEoD;EACR,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASS,yBAAyBA,CAACvC,KAAK,EAAEwC,KAAK,EAAEC,QAAQ,EAAE;EAChE,MAAMrC,aAAa,GAAGoC,KAAK,IAAIA,KAAK,CAACpC,aAAa;EAClD,MAAMC,cAAc,GAAGmC,KAAK,IAAIA,KAAK,CAACnC,cAAc;EACpD,MAAMY,gBAAgB,GAAGuB,KAAK,IAAIA,KAAK,CAACvB,gBAAgB;EACxD,MAAMyB,eAAe,GAAGF,KAAK,IAAIA,KAAK,CAACE,eAAe;EACtD,MAAMC,aAAa,GAAGH,KAAK,IAAIA,KAAK,CAACG,aAAa;EAClD,MAAM3B,mBAAmB,GAAGwB,KAAK,IAAIA,KAAK,CAACxB,mBAAmB,IAAI,EAAE;EACpE,MAAM4B,mBAAmB,GAAG;IAC1BC,KAAK,EAAE7C,KAAK,CAACmB,OAAO,IAAInB,KAAK,CAACmB,OAAO,CAACE,OAAO,IAAIrB,KAAK,CAACmB,OAAO,CAACE,OAAO,CAACO,QAAQ;IAC/EkB,IAAI,EAAE9C,KAAK,CAACmB,OAAO,IAAInB,KAAK,CAACmB,OAAO,CAACgB,MAAM,IAAInC,KAAK,CAACmB,OAAO,CAACgB,MAAM,CAACP,QAAQ;IAC5EmB,IAAI,EAAE/C,KAAK,CAACmB,OAAO,IAAInB,KAAK,CAACmB,OAAO,CAACQ,MAAM,IAAI3B,KAAK,CAACmB,OAAO,CAACQ,MAAM,CAACC,QAAQ;IAC5EoB,IAAI,EAAEhD,KAAK,CAACmB,OAAO,IAAInB,KAAK,CAACmB,OAAO,CAACS;EACvC,CAAC;EACD,MAAMD,MAAM,GAAGA,CAAC9B,KAAK,EAAEnB,IAAI,EAAEyC,OAAO,KAAK;IACvC,IAAIuB,eAAe,EAAE;MACnB,OAAOV,cAAc,CAACb,OAAO,EAAEzC,IAAI,EAAE,MAAM;QACzC+D,QAAQ,CAAC;UACPC,eAAe,EAAE,KAAK;UACtBC,aAAa,EAAE;QACjB,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ;IACA,OAAOpB,kBAAkB,CAACJ,OAAO,EAAEtB,KAAK,EAAEnB,IAAI,EAAE,MAAM;MACpD+D,QAAQ,CAAC;QACPE,aAAa,EAAE;MACjB,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ,CAAC;;EAED;EACA,MAAMR,MAAM,GAAGA,CAACc,KAAK,EAAEpD,KAAK,EAAEnB,IAAI,EAAEyC,OAAO,KAAK;IAC9C,OAAOc,mBAAmB,CAACd,OAAO,EAAEtB,KAAK,EAAEnB,IAAI,EAAEuE,KAAK,EAAE,MAAM;MAC5DR,QAAQ,CAAC;QACPrC,aAAa,EAAE;MACjB,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ,CAAC;;EAED;EACA,MAAMiB,OAAO,GAAGA,CAAC4B,KAAK,EAAEpD,KAAK,EAAEnB,IAAI,EAAEyC,OAAO,KAAK;IAC/C,IAAIF,gBAAgB,EAAE;MACpB,OAAOqB,oBAAoB,CAACnB,OAAO,EAAEzC,IAAI,EAAEuE,KAAK,EAAE,MAAM;QACtDR,QAAQ,CAAC;UACPpC,cAAc,EAAE;QAClB,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ;IACA,OAAO+B,wBAAwB,CAACjB,OAAO,EAAEtB,KAAK,EAAEnB,IAAI,EAAEuE,KAAK,EAAE,MAAM;MACjER,QAAQ,CAAC;QACPxB,gBAAgB,EAAE;MACpB,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ,CAAC;EACD,MAAMiC,0BAA0B,GAAG,SAAAA,CAAUrD,KAAK,EAAEC,IAAI,EAAE;IACxD,MAAMqB,OAAO,GAAGtB,KAAK,CAACG,KAAK,CAACmB,OAAO;IACnC,IAAI,CAACtB,KAAK,CAACC,IAAI,EAAE;MACf,OAAO,CAAC,CAAC;IACX;IACA,MAAMqD,kBAAkB,GAAGtD,KAAK,CAACG,KAAK,IAAIH,KAAK,CAACG,KAAK,CAACoD,KAAK,GAAGvD,KAAK,CAACC,IAAI,CAACuD,uBAAuB,IAAIxD,KAAK,CAACC,IAAI,CAACqD,kBAAkB,GAAGtD,KAAK,CAACC,IAAI,CAACqD,kBAAkB;IACjK,IAAIA,kBAAkB,EAAE;MACtB,MAAMG,iBAAiB,GAAGnC,OAAO,CAACrB,IAAI,CAAC,IAAIqB,OAAO,CAACrB,IAAI,CAAC,CAAC8B,QAAQ;MACjE,OAAO0B,iBAAiB,KAAKC,SAAS,GAAGD,iBAAiB,GAAGH,kBAAkB,CAACrD,IAAI,CAAC,IAAIqD,kBAAkB,CAACrD,IAAI,CAAC,CAAC8B,QAAQ;IAC5H;IACA,OAAO,CAAC,CAAC;EACX,CAAC;;EAED;EACA,OAAO,SAAS4B,kBAAkBA,CAAC3D,KAAK,EAAE4D,KAAK,EAAE;IAC/C,MAAM/E,IAAI,GAAGkB,YAAY,CAACC,KAAK,CAAC,IAAI,EAAE;IACtC,MAAMsB,OAAO,GAAGjD,SAAS,CAAC,CAAC,CAAC,EAAE8B,KAAK,CAACmB,OAAO,EAAEtB,KAAK,CAACG,KAAK,CAACmB,OAAO,CAAC;IACjE,MAAMgC,kBAAkB,GAAGtD,KAAK,CAACG,KAAK,CAACoD,KAAK,GAAGvD,KAAK,CAACC,IAAI,CAACuD,uBAAuB,IAAIxD,KAAK,CAACC,IAAI,CAACqD,kBAAkB,GAAGtD,KAAK,CAACC,IAAI,CAACqD,kBAAkB;IAClJhC,OAAO,CAACgB,MAAM,GAAGjE,SAAS,CAAC,CAAC,CAAC,EAAEiD,OAAO,CAACgB,MAAM,EAAEgB,kBAAkB,IAAIA,kBAAkB,CAAChB,MAAM,CAAC;IAC/FhB,OAAO,CAACE,OAAO,GAAGnD,SAAS,CAAC,CAAC,CAAC,EAAEiD,OAAO,CAACE,OAAO,EAAE8B,kBAAkB,IAAIA,kBAAkB,CAAC9B,OAAO,CAAC;IAClGF,OAAO,CAACQ,MAAM,GAAGzD,SAAS,CAAC,CAAC,CAAC,EAAEiD,OAAO,CAACQ,MAAM,EAAEwB,kBAAkB,IAAIA,kBAAkB,CAACxB,MAAM,CAAC;IAC/F,MAAM+B,gBAAgB,GAAG1C,mBAAmB,CAACyC,KAAK,CAAC,IAAIzC,mBAAmB,CAAC,CAAC,CAAC;IAC7E,IAAI,CAAC2B,aAAa,EAAE;MAClB;MACA,MAAMI,IAAI,GAAGH,mBAAmB,CAACG,IAAI,KAAKQ,SAAS,GAAGX,mBAAmB,CAACG,IAAI,GAAGG,0BAA0B,CAACrD,KAAK,EAAE,QAAQ,CAAC;MAC5H,MAAM8D,SAAS,GAAG;QAChB/B,QAAQ,EAAEmB;MACZ,CAAC;MACD,OAAOpB,MAAM,CAAC9B,KAAK,EAAEnB,IAAI,EAAEQ,MAAM,CAACoC,MAAM,CAAC,CAAC,CAAC,EAAEH,OAAO,EAAEwC,SAAS,CAAC,CAAC;IACnE,CAAC,MAAM,IAAIvD,aAAa,EAAE;MACxB,MAAM8B,YAAY,GAAGwB,gBAAgB,IAAIA,gBAAgB,CAAC/D,OAAO;MACjE,MAAMmD,IAAI,GAAGF,mBAAmB,CAACE,IAAI,KAAKS,SAAS,GAAGX,mBAAmB,CAACE,IAAI,GAAGI,0BAA0B,CAACrD,KAAK,EAAE,QAAQ,CAAC;MAC5H;MACA,MAAM8D,SAAS,GAAGzB,YAAY,GAAG;QAC/BN,QAAQ,EAAEkB;MACZ,CAAC,GAAG;QACFc,KAAK,EAAEd;MACT,CAAC;MACD,OAAOX,MAAM,CAACD,YAAY,EAAErC,KAAK,EAAEnB,IAAI,EAAEQ,MAAM,CAACoC,MAAM,CAAC,CAAC,CAAC,EAAEH,OAAO,EAAEwC,SAAS,CAAC,CAAC;IACjF,CAAC,MAAM,IAAItD,cAAc,EAAE;MACzB,MAAMgC,aAAa,GAAGqB,gBAAgB,IAAIA,gBAAgB,CAAChE,QAAQ;MACnE,MAAMmD,KAAK,GAAGD,mBAAmB,CAACC,KAAK,KAAKU,SAAS,GAAGX,mBAAmB,CAACC,KAAK,GAAGK,0BAA0B,CAACrD,KAAK,EAAE,SAAS,CAAC;MAChI,MAAMmD,IAAI,GAAGJ,mBAAmB,CAACI,IAAI,KAAKO,SAAS,GAAGX,mBAAmB,CAACI,IAAI,GAAGnD,KAAK,CAACG,KAAK,CAACmB,OAAO,IAAItB,KAAK,CAACG,KAAK,CAACmB,OAAO,CAACS,QAAQ;MACpI,MAAM+B,SAAS,GAAG;QAChB/B,QAAQ,EAAEX,gBAAgB,IAAIoB,aAAa,GAAGQ,KAAK,GAAGG;MACxD,CAAC;MACD,OAAO3B,OAAO,CAACgB,aAAa,EAAExC,KAAK,EAAEnB,IAAI,EAAEQ,MAAM,CAACoC,MAAM,CAAC,CAAC,CAAC,EAAEH,OAAO,EAAEwC,SAAS,CAAC,CAAC;IACnF,CAAC,MAAM,IAAI,CAACnB,KAAK,IAAIrB,OAAO,IAAIA,OAAO,CAACgB,MAAM,EAAE;MAC9C;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,OAAOjB,oBAAoB,CAACC,OAAO,EAAEzC,IAAI,CAAC;IAC5C;IACA,OAAO;MACLyC,OAAO;MACPzC;IACF,CAAC;EACH,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _isPlainObject from \"lodash/isPlainObject\";\nimport _defaults from \"lodash/defaults\";\n/* eslint no-magic-numbers: [\"error\", { \"ignore\": [-1, 0, 1, 2, 45, 90, 135, 180, 225, 270, 315, 360] }]*/\nimport * as d3Shape from \"victory-vendor/d3-shape\";\nimport { Helpers, Data, Style } from \"victory-core\";\nconst checkForValidText = text => {\n  if (text === undefined || text === null || Helpers.isFunction(text)) {\n    return text;\n  }\n  return `${text}`;\n};\nconst getColor = (style, colors, index) => {\n  if (style && style.data && style.data.fill) {\n    return style.data.fill;\n  }\n  return colors && colors[index % colors.length];\n};\nconst getRadius = (props, padding) => {\n  if (typeof props.radius === \"number\") {\n    return props.radius;\n  }\n  return Math.min(props.width - padding.left - padding.right, props.height - padding.top - padding.bottom) / 2;\n};\nconst getOrigin = (props, padding) => {\n  const {\n    width,\n    height\n  } = props;\n  const origin = _isPlainObject(props.origin) ? props.origin : {};\n  return {\n    x: origin.x !== undefined ? origin.x : (padding.left - padding.right + width) / 2,\n    y: origin.y !== undefined ? origin.y : (padding.top - padding.bottom + height) / 2\n  };\n};\nconst getSlices = (props, data) => {\n  const padAngle = Helpers.isFunction(props.padAngle) ? 0 : props.padAngle;\n  const layoutFunction = d3Shape.pie().sort(null).startAngle(Helpers.degreesToRadians(props.startAngle)).endAngle(Helpers.degreesToRadians(props.endAngle)).padAngle(Helpers.degreesToRadians(padAngle)).value(datum => {\n    return datum._y;\n  });\n  return layoutFunction(data);\n};\nconst getCalculatedValues = props => {\n  const {\n    colorScale\n  } = props;\n  const styleObject = Helpers.getDefaultStyles(props, \"pie\");\n  const style = Helpers.getStyles(props.style, styleObject);\n  const colors = Array.isArray(colorScale) ? colorScale : Style.getColorScale(colorScale);\n  const padding = Helpers.getPadding(props);\n  const defaultRadius = getRadius(props, padding);\n  const origin = getOrigin(props, padding);\n  const data = Data.getData(props);\n  const slices = getSlices(props, data);\n  return Object.assign({}, props, {\n    style,\n    colors,\n    padding,\n    defaultRadius,\n    data,\n    slices,\n    origin\n  });\n};\nconst getSliceStyle = (index, calculatedValues) => {\n  const {\n    style,\n    colors\n  } = calculatedValues;\n  const fill = getColor(style, colors, index);\n  return Object.assign({\n    fill\n  }, style.data);\n};\nconst getLabelText = (props, datum, index) => {\n  let text;\n  if (datum.label) {\n    text = datum.label;\n  } else if (Array.isArray(props.labels)) {\n    text = props.labels[index];\n  } else {\n    text = Helpers.isFunction(props.labels) ? props.labels : datum.xName || datum._x;\n  }\n  return checkForValidText(text);\n};\nconst getLabelArc = labelRadius => {\n  return d3Shape.arc().outerRadius(labelRadius).innerRadius(labelRadius);\n};\nconst getCalculatedLabelRadius = (radius, labelRadius, style) => {\n  const padding = style && style.padding || 0;\n  return labelRadius || radius + padding;\n};\nconst getLabelPosition = (arc, slice, position) => {\n  const construct = {\n    startAngle: position === \"startAngle\" ? slice.startAngle : slice.endAngle,\n    endAngle: position === \"endAngle\" ? slice.endAngle : slice.startAngle\n  };\n  const clonedArc = Object.assign({}, slice, construct);\n  return arc.centroid(clonedArc);\n};\nconst getLabelOrientation = (degree, labelPlacement) => {\n  if (labelPlacement === \"perpendicular\") {\n    return degree > 90 && degree < 270 ? \"bottom\" : \"top\";\n  } else if (labelPlacement === \"parallel\") {\n    return degree >= 0 && degree <= 180 ? \"right\" : \"left\";\n  }\n  if (degree < 45 || degree > 315) {\n    return \"top\";\n  } else if (degree >= 45 && degree < 135) {\n    return \"right\";\n  } else if (degree >= 135 && degree < 225) {\n    return \"bottom\";\n  }\n  return \"left\";\n};\nconst getTextAnchor = orientation => {\n  if (orientation === \"top\" || orientation === \"bottom\") {\n    return \"middle\";\n  }\n  return orientation === \"right\" ? \"start\" : \"end\";\n};\nconst getVerticalAnchor = orientation => {\n  if (orientation === \"left\" || orientation === \"right\") {\n    return \"middle\";\n  }\n  return orientation === \"bottom\" ? \"start\" : \"end\";\n};\nconst getBaseLabelAngle = (slice, labelPosition, labelStyle) => {\n  let baseAngle = 0;\n  if (labelPosition.angle !== undefined) {\n    baseAngle = labelStyle.angle;\n  } else if (labelPosition === \"centroid\") {\n    baseAngle = Helpers.radiansToDegrees((slice.startAngle + slice.endAngle) / 2);\n  } else {\n    baseAngle = labelPosition === \"startAngle\" ? Helpers.radiansToDegrees(slice.startAngle) : Helpers.radiansToDegrees(slice.endAngle);\n  }\n  const positiveAngle = baseAngle < 0 ? 360 - baseAngle : baseAngle;\n  return positiveAngle % 360;\n};\nconst getLabelAngle = (baseAngle, labelPlacement) => {\n  if (labelPlacement === \"vertical\") {\n    return 0;\n  }\n  if (labelPlacement === \"parallel\") {\n    return baseAngle > 180 && baseAngle < 360 ? baseAngle + 90 : baseAngle - 90;\n  }\n  return baseAngle > 90 && baseAngle < 270 ? baseAngle - 180 : baseAngle;\n};\nconst getLabelProps = (text, dataProps, calculatedValues) => {\n  const {\n    index,\n    datum,\n    data,\n    slice,\n    labelComponent,\n    theme\n  } = dataProps;\n  const {\n    style,\n    defaultRadius,\n    origin,\n    width,\n    height\n  } = calculatedValues;\n  const labelRadius = Helpers.evaluateProp(calculatedValues.labelRadius, Object.assign({\n    text\n  }, dataProps));\n  const labelPosition = Helpers.evaluateProp(calculatedValues.labelPosition, Object.assign({\n    text\n  }, dataProps)) || \"centroid\";\n  const labelPlacement = Helpers.evaluateProp(calculatedValues.labelPlacement, Object.assign({\n    text\n  }, dataProps)) || \"vertical\";\n  const labelStyle = Object.assign({\n    padding: 0\n  }, style.labels);\n  const evaluatedStyle = Helpers.evaluateStyle(labelStyle, Object.assign({\n    labelRadius,\n    text\n  }, dataProps));\n  const calculatedLabelRadius = getCalculatedLabelRadius(defaultRadius, labelRadius, evaluatedStyle);\n  const labelArc = getLabelArc(calculatedLabelRadius);\n  const position = getLabelPosition(labelArc, slice, labelPosition);\n  const baseAngle = getBaseLabelAngle(slice, labelPosition, labelStyle);\n  const labelAngle = getLabelAngle(baseAngle, labelPlacement);\n  const orientation = getLabelOrientation(baseAngle, labelPlacement);\n  const textAnchor = labelStyle.textAnchor || getTextAnchor(orientation);\n  const verticalAnchor = labelStyle.verticalAnchor || getVerticalAnchor(orientation);\n  const labelProps = {\n    width,\n    height,\n    index,\n    datum,\n    data,\n    slice,\n    orientation,\n    text,\n    style: labelStyle,\n    x: Math.round(position[0]) + origin.x,\n    y: Math.round(position[1]) + origin.y,\n    textAnchor,\n    verticalAnchor,\n    angle: labelAngle,\n    calculatedLabelRadius\n  };\n  if (!Helpers.isTooltip(labelComponent)) {\n    return labelProps;\n  }\n  const tooltipTheme = theme && theme.tooltip || {};\n  return _defaults({}, labelProps, Helpers.omit(tooltipTheme, [\"style\"]));\n};\nexport const getXOffsetMultiplayerByAngle = angle => Math.cos(angle - Helpers.degreesToRadians(90));\nexport const getYOffsetMultiplayerByAngle = angle => Math.sin(angle - Helpers.degreesToRadians(90));\nexport const getXOffset = (offset, angle) => offset * getXOffsetMultiplayerByAngle(angle);\nexport const getYOffset = (offset, angle) => offset * getYOffsetMultiplayerByAngle(angle);\nexport const getAverage = array => array.reduce((acc, cur) => acc + cur, 0) / array.length;\nexport const getLabelIndicatorPropsForLineSegment = (props, calculatedValues, labelProps) => {\n  const {\n    innerRadius,\n    radius,\n    slice: {\n      startAngle,\n      endAngle\n    },\n    labelIndicatorInnerOffset,\n    labelIndicatorOuterOffset,\n    index\n  } = props;\n  const {\n    height,\n    width\n  } = calculatedValues;\n  const {\n    calculatedLabelRadius\n  } = labelProps;\n  // calculation\n  const middleRadius = getAverage([innerRadius, radius]);\n  const midAngle = getAverage([endAngle, startAngle]);\n  const centerX = width / 2;\n  const centerY = height / 2;\n  const innerOffset = middleRadius + labelIndicatorInnerOffset;\n  const outerOffset = calculatedLabelRadius - labelIndicatorOuterOffset;\n  const x1 = centerX + getXOffset(innerOffset, midAngle);\n  const y1 = centerY + getYOffset(innerOffset, midAngle);\n  const x2 = centerX + getXOffset(outerOffset, midAngle);\n  const y2 = centerY + getYOffset(outerOffset, midAngle);\n  const labelIndicatorProps = {\n    x1,\n    y1,\n    x2,\n    y2,\n    index\n  };\n  return _defaults({}, labelIndicatorProps);\n};\nexport const getBaseProps = (initialProps, fallbackProps) => {\n  const props = Helpers.modifyProps(initialProps, fallbackProps, \"pie\");\n  const calculatedValues = getCalculatedValues(props);\n  const {\n    slices,\n    style,\n    data,\n    origin,\n    defaultRadius,\n    labels,\n    events,\n    sharedEvents,\n    height,\n    width,\n    standalone,\n    name,\n    innerRadius,\n    cornerRadius,\n    padAngle,\n    disableInlineStyles,\n    labelIndicator\n  } = calculatedValues;\n  const radius = props.radius || defaultRadius;\n  const initialChildProps = {\n    parent: {\n      standalone,\n      height,\n      width,\n      slices,\n      name,\n      style: style.parent\n    }\n  };\n  return slices.reduce((childProps, slice, index) => {\n    const datum = _defaults({}, data[index], {\n      startAngle: Helpers.radiansToDegrees(slice.startAngle),\n      endAngle: Helpers.radiansToDegrees(slice.endAngle),\n      padAngle: Helpers.radiansToDegrees(slice.padAngle)\n    });\n    const eventKey = !Helpers.isNil(datum.eventKey) ? datum.eventKey : index;\n    const dataProps = {\n      index,\n      slice,\n      datum,\n      data,\n      origin,\n      innerRadius,\n      radius,\n      cornerRadius,\n      padAngle,\n      style: disableInlineStyles ? {} : getSliceStyle(index, calculatedValues),\n      disableInlineStyles\n    };\n    childProps[eventKey] = {\n      data: dataProps\n    };\n    const text = getLabelText(props, datum, index);\n    if (text !== undefined && text !== null || labels && (events || sharedEvents)) {\n      const evaluatedText = Helpers.evaluateProp(text, dataProps);\n      childProps[eventKey].labels = getLabelProps(evaluatedText, Object.assign({}, props, dataProps), calculatedValues);\n      if (labelIndicator) {\n        const labelProps = childProps[eventKey].labels;\n        if (labelProps.calculatedLabelRadius > radius) {\n          childProps[eventKey].labelIndicators = getLabelIndicatorPropsForLineSegment(Object.assign({}, props, dataProps), calculatedValues, labelProps);\n        }\n      }\n    }\n    return childProps;\n  }, initialChildProps);\n};","map":{"version":3,"names":["_isPlainObject","_defaults","d3Shape","Helpers","Data","Style","checkForValidText","text","undefined","isFunction","getColor","style","colors","index","data","fill","length","getRadius","props","padding","radius","Math","min","width","left","right","height","top","bottom","getOrigin","origin","x","y","getSlices","padAngle","layoutFunction","pie","sort","startAngle","degreesToRadians","endAngle","value","datum","_y","getCalculatedValues","colorScale","styleObject","getDefaultStyles","getStyles","Array","isArray","getColorScale","getPadding","defaultRadius","getData","slices","Object","assign","getSliceStyle","calculatedValues","getLabelText","label","labels","xName","_x","getLabelArc","labelRadius","arc","outerRadius","innerRadius","getCalculatedLabelRadius","getLabelPosition","slice","position","construct","clonedArc","centroid","getLabelOrientation","degree","labelPlacement","getTextAnchor","orientation","getVerticalAnchor","getBaseLabelAngle","labelPosition","labelStyle","baseAngle","angle","radiansToDegrees","positiveAngle","getLabelAngle","getLabelProps","dataProps","labelComponent","theme","evaluateProp","evaluatedStyle","evaluateStyle","calculatedLabelRadius","labelArc","labelAngle","textAnchor","verticalAnchor","labelProps","round","isTooltip","tooltipTheme","tooltip","omit","getXOffsetMultiplayerByAngle","cos","getYOffsetMultiplayerByAngle","sin","getXOffset","offset","getYOffset","getAverage","array","reduce","acc","cur","getLabelIndicatorPropsForLineSegment","labelIndicatorInnerOffset","labelIndicatorOuterOffset","middleRadius","midAngle","centerX","centerY","innerOffset","outerOffset","x1","y1","x2","y2","labelIndicatorProps","getBaseProps","initialProps","fallbackProps","modifyProps","events","sharedEvents","standalone","name","cornerRadius","disableInlineStyles","labelIndicator","initialChildProps","parent","childProps","eventKey","isNil","evaluatedText","labelIndicators"],"sources":["/Users/anjalichaturvedi/GitHub/brew-bridge-dashboard/website/node_modules/victory-pie/es/helper-methods.js"],"sourcesContent":["import _isPlainObject from \"lodash/isPlainObject\";\nimport _defaults from \"lodash/defaults\";\n/* eslint no-magic-numbers: [\"error\", { \"ignore\": [-1, 0, 1, 2, 45, 90, 135, 180, 225, 270, 315, 360] }]*/\nimport * as d3Shape from \"victory-vendor/d3-shape\";\nimport { Helpers, Data, Style } from \"victory-core\";\nconst checkForValidText = text => {\n  if (text === undefined || text === null || Helpers.isFunction(text)) {\n    return text;\n  }\n  return `${text}`;\n};\nconst getColor = (style, colors, index) => {\n  if (style && style.data && style.data.fill) {\n    return style.data.fill;\n  }\n  return colors && colors[index % colors.length];\n};\nconst getRadius = (props, padding) => {\n  if (typeof props.radius === \"number\") {\n    return props.radius;\n  }\n  return Math.min(props.width - padding.left - padding.right, props.height - padding.top - padding.bottom) / 2;\n};\nconst getOrigin = (props, padding) => {\n  const {\n    width,\n    height\n  } = props;\n  const origin = _isPlainObject(props.origin) ? props.origin : {};\n  return {\n    x: origin.x !== undefined ? origin.x : (padding.left - padding.right + width) / 2,\n    y: origin.y !== undefined ? origin.y : (padding.top - padding.bottom + height) / 2\n  };\n};\nconst getSlices = (props, data) => {\n  const padAngle = Helpers.isFunction(props.padAngle) ? 0 : props.padAngle;\n  const layoutFunction = d3Shape.pie().sort(null).startAngle(Helpers.degreesToRadians(props.startAngle)).endAngle(Helpers.degreesToRadians(props.endAngle)).padAngle(Helpers.degreesToRadians(padAngle)).value(datum => {\n    return datum._y;\n  });\n  return layoutFunction(data);\n};\nconst getCalculatedValues = props => {\n  const {\n    colorScale\n  } = props;\n  const styleObject = Helpers.getDefaultStyles(props, \"pie\");\n  const style = Helpers.getStyles(props.style, styleObject);\n  const colors = Array.isArray(colorScale) ? colorScale : Style.getColorScale(colorScale);\n  const padding = Helpers.getPadding(props);\n  const defaultRadius = getRadius(props, padding);\n  const origin = getOrigin(props, padding);\n  const data = Data.getData(props);\n  const slices = getSlices(props, data);\n  return Object.assign({}, props, {\n    style,\n    colors,\n    padding,\n    defaultRadius,\n    data,\n    slices,\n    origin\n  });\n};\nconst getSliceStyle = (index, calculatedValues) => {\n  const {\n    style,\n    colors\n  } = calculatedValues;\n  const fill = getColor(style, colors, index);\n  return Object.assign({\n    fill\n  }, style.data);\n};\nconst getLabelText = (props, datum, index) => {\n  let text;\n  if (datum.label) {\n    text = datum.label;\n  } else if (Array.isArray(props.labels)) {\n    text = props.labels[index];\n  } else {\n    text = Helpers.isFunction(props.labels) ? props.labels : datum.xName || datum._x;\n  }\n  return checkForValidText(text);\n};\nconst getLabelArc = labelRadius => {\n  return d3Shape.arc().outerRadius(labelRadius).innerRadius(labelRadius);\n};\nconst getCalculatedLabelRadius = (radius, labelRadius, style) => {\n  const padding = style && style.padding || 0;\n  return labelRadius || radius + padding;\n};\nconst getLabelPosition = (arc, slice, position) => {\n  const construct = {\n    startAngle: position === \"startAngle\" ? slice.startAngle : slice.endAngle,\n    endAngle: position === \"endAngle\" ? slice.endAngle : slice.startAngle\n  };\n  const clonedArc = Object.assign({}, slice, construct);\n  return arc.centroid(clonedArc);\n};\nconst getLabelOrientation = (degree, labelPlacement) => {\n  if (labelPlacement === \"perpendicular\") {\n    return degree > 90 && degree < 270 ? \"bottom\" : \"top\";\n  } else if (labelPlacement === \"parallel\") {\n    return degree >= 0 && degree <= 180 ? \"right\" : \"left\";\n  }\n  if (degree < 45 || degree > 315) {\n    return \"top\";\n  } else if (degree >= 45 && degree < 135) {\n    return \"right\";\n  } else if (degree >= 135 && degree < 225) {\n    return \"bottom\";\n  }\n  return \"left\";\n};\nconst getTextAnchor = orientation => {\n  if (orientation === \"top\" || orientation === \"bottom\") {\n    return \"middle\";\n  }\n  return orientation === \"right\" ? \"start\" : \"end\";\n};\nconst getVerticalAnchor = orientation => {\n  if (orientation === \"left\" || orientation === \"right\") {\n    return \"middle\";\n  }\n  return orientation === \"bottom\" ? \"start\" : \"end\";\n};\nconst getBaseLabelAngle = (slice, labelPosition, labelStyle) => {\n  let baseAngle = 0;\n  if (labelPosition.angle !== undefined) {\n    baseAngle = labelStyle.angle;\n  } else if (labelPosition === \"centroid\") {\n    baseAngle = Helpers.radiansToDegrees((slice.startAngle + slice.endAngle) / 2);\n  } else {\n    baseAngle = labelPosition === \"startAngle\" ? Helpers.radiansToDegrees(slice.startAngle) : Helpers.radiansToDegrees(slice.endAngle);\n  }\n  const positiveAngle = baseAngle < 0 ? 360 - baseAngle : baseAngle;\n  return positiveAngle % 360;\n};\nconst getLabelAngle = (baseAngle, labelPlacement) => {\n  if (labelPlacement === \"vertical\") {\n    return 0;\n  }\n  if (labelPlacement === \"parallel\") {\n    return baseAngle > 180 && baseAngle < 360 ? baseAngle + 90 : baseAngle - 90;\n  }\n  return baseAngle > 90 && baseAngle < 270 ? baseAngle - 180 : baseAngle;\n};\nconst getLabelProps = (text, dataProps, calculatedValues) => {\n  const {\n    index,\n    datum,\n    data,\n    slice,\n    labelComponent,\n    theme\n  } = dataProps;\n  const {\n    style,\n    defaultRadius,\n    origin,\n    width,\n    height\n  } = calculatedValues;\n  const labelRadius = Helpers.evaluateProp(calculatedValues.labelRadius, Object.assign({\n    text\n  }, dataProps));\n  const labelPosition = Helpers.evaluateProp(calculatedValues.labelPosition, Object.assign({\n    text\n  }, dataProps)) || \"centroid\";\n  const labelPlacement = Helpers.evaluateProp(calculatedValues.labelPlacement, Object.assign({\n    text\n  }, dataProps)) || \"vertical\";\n  const labelStyle = Object.assign({\n    padding: 0\n  }, style.labels);\n  const evaluatedStyle = Helpers.evaluateStyle(labelStyle, Object.assign({\n    labelRadius,\n    text\n  }, dataProps));\n  const calculatedLabelRadius = getCalculatedLabelRadius(defaultRadius, labelRadius, evaluatedStyle);\n  const labelArc = getLabelArc(calculatedLabelRadius);\n  const position = getLabelPosition(labelArc, slice, labelPosition);\n  const baseAngle = getBaseLabelAngle(slice, labelPosition, labelStyle);\n  const labelAngle = getLabelAngle(baseAngle, labelPlacement);\n  const orientation = getLabelOrientation(baseAngle, labelPlacement);\n  const textAnchor = labelStyle.textAnchor || getTextAnchor(orientation);\n  const verticalAnchor = labelStyle.verticalAnchor || getVerticalAnchor(orientation);\n  const labelProps = {\n    width,\n    height,\n    index,\n    datum,\n    data,\n    slice,\n    orientation,\n    text,\n    style: labelStyle,\n    x: Math.round(position[0]) + origin.x,\n    y: Math.round(position[1]) + origin.y,\n    textAnchor,\n    verticalAnchor,\n    angle: labelAngle,\n    calculatedLabelRadius\n  };\n  if (!Helpers.isTooltip(labelComponent)) {\n    return labelProps;\n  }\n  const tooltipTheme = theme && theme.tooltip || {};\n  return _defaults({}, labelProps, Helpers.omit(tooltipTheme, [\"style\"]));\n};\nexport const getXOffsetMultiplayerByAngle = angle => Math.cos(angle - Helpers.degreesToRadians(90));\nexport const getYOffsetMultiplayerByAngle = angle => Math.sin(angle - Helpers.degreesToRadians(90));\nexport const getXOffset = (offset, angle) => offset * getXOffsetMultiplayerByAngle(angle);\nexport const getYOffset = (offset, angle) => offset * getYOffsetMultiplayerByAngle(angle);\nexport const getAverage = array => array.reduce((acc, cur) => acc + cur, 0) / array.length;\nexport const getLabelIndicatorPropsForLineSegment = (props, calculatedValues, labelProps) => {\n  const {\n    innerRadius,\n    radius,\n    slice: {\n      startAngle,\n      endAngle\n    },\n    labelIndicatorInnerOffset,\n    labelIndicatorOuterOffset,\n    index\n  } = props;\n  const {\n    height,\n    width\n  } = calculatedValues;\n  const {\n    calculatedLabelRadius\n  } = labelProps;\n  // calculation\n  const middleRadius = getAverage([innerRadius, radius]);\n  const midAngle = getAverage([endAngle, startAngle]);\n  const centerX = width / 2;\n  const centerY = height / 2;\n  const innerOffset = middleRadius + labelIndicatorInnerOffset;\n  const outerOffset = calculatedLabelRadius - labelIndicatorOuterOffset;\n  const x1 = centerX + getXOffset(innerOffset, midAngle);\n  const y1 = centerY + getYOffset(innerOffset, midAngle);\n  const x2 = centerX + getXOffset(outerOffset, midAngle);\n  const y2 = centerY + getYOffset(outerOffset, midAngle);\n  const labelIndicatorProps = {\n    x1,\n    y1,\n    x2,\n    y2,\n    index\n  };\n  return _defaults({}, labelIndicatorProps);\n};\nexport const getBaseProps = (initialProps, fallbackProps) => {\n  const props = Helpers.modifyProps(initialProps, fallbackProps, \"pie\");\n  const calculatedValues = getCalculatedValues(props);\n  const {\n    slices,\n    style,\n    data,\n    origin,\n    defaultRadius,\n    labels,\n    events,\n    sharedEvents,\n    height,\n    width,\n    standalone,\n    name,\n    innerRadius,\n    cornerRadius,\n    padAngle,\n    disableInlineStyles,\n    labelIndicator\n  } = calculatedValues;\n  const radius = props.radius || defaultRadius;\n  const initialChildProps = {\n    parent: {\n      standalone,\n      height,\n      width,\n      slices,\n      name,\n      style: style.parent\n    }\n  };\n  return slices.reduce((childProps, slice, index) => {\n    const datum = _defaults({}, data[index], {\n      startAngle: Helpers.radiansToDegrees(slice.startAngle),\n      endAngle: Helpers.radiansToDegrees(slice.endAngle),\n      padAngle: Helpers.radiansToDegrees(slice.padAngle)\n    });\n    const eventKey = !Helpers.isNil(datum.eventKey) ? datum.eventKey : index;\n    const dataProps = {\n      index,\n      slice,\n      datum,\n      data,\n      origin,\n      innerRadius,\n      radius,\n      cornerRadius,\n      padAngle,\n      style: disableInlineStyles ? {} : getSliceStyle(index, calculatedValues),\n      disableInlineStyles\n    };\n    childProps[eventKey] = {\n      data: dataProps\n    };\n    const text = getLabelText(props, datum, index);\n    if (text !== undefined && text !== null || labels && (events || sharedEvents)) {\n      const evaluatedText = Helpers.evaluateProp(text, dataProps);\n      childProps[eventKey].labels = getLabelProps(evaluatedText, Object.assign({}, props, dataProps), calculatedValues);\n      if (labelIndicator) {\n        const labelProps = childProps[eventKey].labels;\n        if (labelProps.calculatedLabelRadius > radius) {\n          childProps[eventKey].labelIndicators = getLabelIndicatorPropsForLineSegment(Object.assign({}, props, dataProps), calculatedValues, labelProps);\n        }\n      }\n    }\n    return childProps;\n  }, initialChildProps);\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _orderBy from \"lodash/orderBy\";\nimport _isPlainObject from \"lodash/isPlainObject\";\nimport { interpolate } from \"victory-vendor/d3-interpolate\";\nexport const isInterpolatable = function (obj) {\n  // d3 turns null into 0 and undefined into NaN, which we don't want.\n  if (obj !== null) {\n    switch (typeof obj) {\n      case \"undefined\":\n        return false;\n      case \"number\":\n        // The standard `isNaN` is fine in this case since we already know the\n        // type is number.\n        return !isNaN(obj) && obj !== Number.POSITIVE_INFINITY && obj !== Number.NEGATIVE_INFINITY;\n      case \"string\":\n        // d3 might not *actually* be able to interpolate the string, but it\n        // won't cause any issues to let it try.\n        return true;\n      case \"boolean\":\n        // d3 turns Booleans into integers, which we don't want. Sure, we could\n        // interpolate from 0 -> 1, but we'd be sending a non-Boolean to\n        // something expecting a Boolean.\n        return false;\n      case \"object\":\n        // Don't try to interpolate class instances (except Date or Array).\n        return obj instanceof Date || Array.isArray(obj) || _isPlainObject(obj);\n      case \"function\":\n        // Careful! There may be extra properties on function objects that the\n        // component expects to access - for instance, it may be a `d3.scale()`\n        // function, which has its own methods attached. We don't know if the\n        // component is only going to call the function (in which case it's\n        // safely interpolatable) or if it's going to access special properties\n        // (in which case our function generated from `interpolateFunction` will\n        // most likely cause an error). We could check for enumerable properties\n        // on the function object here to see if it's a \"plain\" function, but\n        // let's just require that components prevent such function props from\n        // being animated in the first place.\n        return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Interpolate immediately to the end value at the given step `when`.\n * Some nicer default behavior might be to jump at the halfway point or return\n * `a` if `t` is 0 (instead of always returning `b`). But d3's default\n * interpolator does not do these things:\n *\n *   d3.interpolate('aaa', 'bbb')(0) === 'bbb'\n *\n * ...and things might get wonky if we don't replicate that behavior.\n *\n * @param {any} a - Start value.\n * @param {any} b - End value.\n * @param {Number} when - Step value (0 to 1) at which to jump to `b`.\n * @returns {Function} An interpolation function.\n */\nexport const interpolateImmediate = function (a, b, when) {\n  if (when === void 0) {\n    when = 0;\n  }\n  return function (t) {\n    return t < when ? a : b;\n  };\n};\n\n/**\n * Interpolate to or from a function. The interpolated value will be a function\n * that calls `a` (if it's a function) and `b` (if it's a function) and calls\n * `d3.interpolate` on the resulting values. Note that our function won't\n * necessarily be called (that's up to the component this eventually gets\n * passed to) - but if it does get called, it will return an appropriately\n * interpolated value.\n *\n * @param {any} a - Start value.\n * @param {any} b - End value.\n * @returns {Function} An interpolation function.\n */\nexport const interpolateFunction = function (a, b) {\n  return function (t) {\n    if (t >= 1) {\n      return b;\n    }\n    return function () {\n      /* eslint-disable no-invalid-this, prefer-rest-params */\n      const aval = typeof a === \"function\" ? a.apply(this, arguments) : a;\n      const bval = typeof b === \"function\" ? b.apply(this, arguments) : b;\n      return interpolate(aval, bval)(t);\n    };\n  };\n};\n\n/**\n * Interpolate to or from an object. This method is a modification of the object interpolator in\n * d3-interpolate https://github.com/d3/d3-interpolate/blob/master/src/object.js. This interpolator\n * differs in that it uses our custom interpolators when interpolating the value of each property in\n * an object. This allows the correct interpolation of nested objects, including styles\n *\n * @param {any} startValue - Start value.\n * @param {any} endValue - End value.\n * @returns {Function} An interpolation function.\n */\nexport const interpolateObject = function (startValue, endValue) {\n  const interpolateTypes = (x, y) => {\n    if (x === y || !isInterpolatable(x) || !isInterpolatable(y)) {\n      return interpolateImmediate(x, y);\n    }\n    if (typeof x === \"function\" || typeof y === \"function\") {\n      return interpolateFunction(x, y);\n    }\n    if (typeof x === \"object\" && _isPlainObject(x) || typeof y === \"object\" && _isPlainObject(y)) {\n      return interpolateObject(x, y);\n    }\n    return interpolate(x, y);\n  };\n\n  // When the value is an array, attempt to sort by \"key\" so that animating nodes may be identified\n  // based on \"key\" instead of index\n  const keyData = val => {\n    return Array.isArray(val) ? _orderBy(val, \"key\") : val;\n  };\n  const i = {};\n  const c = {};\n  let a = startValue;\n  let b = endValue;\n  let k;\n  if (a === null || typeof a !== \"object\") {\n    a = {};\n  }\n  if (b === null || typeof b !== \"object\") {\n    b = {};\n  }\n  for (k in b) {\n    if (k in a) {\n      i[k] = interpolateTypes(keyData(a[k]), keyData(b[k]));\n    } else {\n      c[k] = b[k];\n    }\n  }\n  return function (t) {\n    for (k in i) {\n      c[k] = i[k](t);\n    }\n    return c;\n  };\n};\nexport const interpolateString = function (a, b) {\n  const format = val => {\n    return typeof val === \"string\" ? val.replace(/,/g, \"\") : val;\n  };\n  return interpolate(format(a), format(b));\n};\n\n/**\n * By default, the list of interpolators used by `d3.interpolate` has a few\n * downsides:\n *\n * - `null` values get turned into 0.\n * - `undefined`, `function`, and some other value types get turned into NaN.\n * - Boolean types get turned into numbers, which probably will be meaningless\n *   to whatever is consuming them.\n * - It tries to interpolate between identical start and end values, doing\n *   unnecessary calculations that sometimes result in floating point rounding\n *   errors.\n *\n * If only the default interpolators are used, `VictoryAnimation` will happily\n * pass down NaN (and other bad) values as props to the wrapped component.\n * The component will then either use the incorrect values or complain that it\n * was passed props of the incorrect type. This custom interpolator is added\n * using the `d3.interpolators` API, and prevents such cases from happening\n * for most values.\n *\n * @param {any} a - Start value.\n * @param {any} b - End value.\n * @returns {Function|undefined} An interpolation function, if necessary.\n */\nexport const victoryInterpolator = function (a, b) {\n  // If the values are strictly equal, or either value is not interpolatable,\n  // just use either the start value `a` or end value `b` at every step, as\n  // there is no reasonable in-between value.\n  if (a === b || !isInterpolatable(a) || !isInterpolatable(b)) {\n    return interpolateImmediate(a, b);\n  }\n  if (typeof a === \"function\" || typeof b === \"function\") {\n    return interpolateFunction(a, b);\n  }\n  if (_isPlainObject(a) || _isPlainObject(b)) {\n    // @ts-expect-error These generics are tough, but they work :)\n    return interpolateObject(a, b);\n  }\n  if (typeof a === \"string\" || typeof b === \"string\") {\n    return interpolateString(a, b);\n  }\n  // @ts-expect-error These generics are tough, but they work :)\n  return interpolate(a, b);\n};","map":{"version":3,"names":["_orderBy","_isPlainObject","interpolate","isInterpolatable","obj","isNaN","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","Date","Array","isArray","interpolateImmediate","a","b","when","t","interpolateFunction","aval","apply","arguments","bval","interpolateObject","startValue","endValue","interpolateTypes","x","y","keyData","val","i","c","k","interpolateString","format","replace","victoryInterpolator"],"sources":["/Users/anjalichaturvedi/GitHub/brew-bridge-dashboard/website/node_modules/victory-core/es/victory-animation/util.js"],"sourcesContent":["import _orderBy from \"lodash/orderBy\";\nimport _isPlainObject from \"lodash/isPlainObject\";\nimport { interpolate } from \"victory-vendor/d3-interpolate\";\nexport const isInterpolatable = function (obj) {\n  // d3 turns null into 0 and undefined into NaN, which we don't want.\n  if (obj !== null) {\n    switch (typeof obj) {\n      case \"undefined\":\n        return false;\n      case \"number\":\n        // The standard `isNaN` is fine in this case since we already know the\n        // type is number.\n        return !isNaN(obj) && obj !== Number.POSITIVE_INFINITY && obj !== Number.NEGATIVE_INFINITY;\n      case \"string\":\n        // d3 might not *actually* be able to interpolate the string, but it\n        // won't cause any issues to let it try.\n        return true;\n      case \"boolean\":\n        // d3 turns Booleans into integers, which we don't want. Sure, we could\n        // interpolate from 0 -> 1, but we'd be sending a non-Boolean to\n        // something expecting a Boolean.\n        return false;\n      case \"object\":\n        // Don't try to interpolate class instances (except Date or Array).\n        return obj instanceof Date || Array.isArray(obj) || _isPlainObject(obj);\n      case \"function\":\n        // Careful! There may be extra properties on function objects that the\n        // component expects to access - for instance, it may be a `d3.scale()`\n        // function, which has its own methods attached. We don't know if the\n        // component is only going to call the function (in which case it's\n        // safely interpolatable) or if it's going to access special properties\n        // (in which case our function generated from `interpolateFunction` will\n        // most likely cause an error). We could check for enumerable properties\n        // on the function object here to see if it's a \"plain\" function, but\n        // let's just require that components prevent such function props from\n        // being animated in the first place.\n        return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Interpolate immediately to the end value at the given step `when`.\n * Some nicer default behavior might be to jump at the halfway point or return\n * `a` if `t` is 0 (instead of always returning `b`). But d3's default\n * interpolator does not do these things:\n *\n *   d3.interpolate('aaa', 'bbb')(0) === 'bbb'\n *\n * ...and things might get wonky if we don't replicate that behavior.\n *\n * @param {any} a - Start value.\n * @param {any} b - End value.\n * @param {Number} when - Step value (0 to 1) at which to jump to `b`.\n * @returns {Function} An interpolation function.\n */\nexport const interpolateImmediate = function (a, b, when) {\n  if (when === void 0) {\n    when = 0;\n  }\n  return function (t) {\n    return t < when ? a : b;\n  };\n};\n\n/**\n * Interpolate to or from a function. The interpolated value will be a function\n * that calls `a` (if it's a function) and `b` (if it's a function) and calls\n * `d3.interpolate` on the resulting values. Note that our function won't\n * necessarily be called (that's up to the component this eventually gets\n * passed to) - but if it does get called, it will return an appropriately\n * interpolated value.\n *\n * @param {any} a - Start value.\n * @param {any} b - End value.\n * @returns {Function} An interpolation function.\n */\nexport const interpolateFunction = function (a, b) {\n  return function (t) {\n    if (t >= 1) {\n      return b;\n    }\n    return function () {\n      /* eslint-disable no-invalid-this, prefer-rest-params */\n      const aval = typeof a === \"function\" ? a.apply(this, arguments) : a;\n      const bval = typeof b === \"function\" ? b.apply(this, arguments) : b;\n      return interpolate(aval, bval)(t);\n    };\n  };\n};\n\n/**\n * Interpolate to or from an object. This method is a modification of the object interpolator in\n * d3-interpolate https://github.com/d3/d3-interpolate/blob/master/src/object.js. This interpolator\n * differs in that it uses our custom interpolators when interpolating the value of each property in\n * an object. This allows the correct interpolation of nested objects, including styles\n *\n * @param {any} startValue - Start value.\n * @param {any} endValue - End value.\n * @returns {Function} An interpolation function.\n */\nexport const interpolateObject = function (startValue, endValue) {\n  const interpolateTypes = (x, y) => {\n    if (x === y || !isInterpolatable(x) || !isInterpolatable(y)) {\n      return interpolateImmediate(x, y);\n    }\n    if (typeof x === \"function\" || typeof y === \"function\") {\n      return interpolateFunction(x, y);\n    }\n    if (typeof x === \"object\" && _isPlainObject(x) || typeof y === \"object\" && _isPlainObject(y)) {\n      return interpolateObject(x, y);\n    }\n    return interpolate(x, y);\n  };\n\n  // When the value is an array, attempt to sort by \"key\" so that animating nodes may be identified\n  // based on \"key\" instead of index\n  const keyData = val => {\n    return Array.isArray(val) ? _orderBy(val, \"key\") : val;\n  };\n  const i = {};\n  const c = {};\n  let a = startValue;\n  let b = endValue;\n  let k;\n  if (a === null || typeof a !== \"object\") {\n    a = {};\n  }\n  if (b === null || typeof b !== \"object\") {\n    b = {};\n  }\n  for (k in b) {\n    if (k in a) {\n      i[k] = interpolateTypes(keyData(a[k]), keyData(b[k]));\n    } else {\n      c[k] = b[k];\n    }\n  }\n  return function (t) {\n    for (k in i) {\n      c[k] = i[k](t);\n    }\n    return c;\n  };\n};\nexport const interpolateString = function (a, b) {\n  const format = val => {\n    return typeof val === \"string\" ? val.replace(/,/g, \"\") : val;\n  };\n  return interpolate(format(a), format(b));\n};\n\n/**\n * By default, the list of interpolators used by `d3.interpolate` has a few\n * downsides:\n *\n * - `null` values get turned into 0.\n * - `undefined`, `function`, and some other value types get turned into NaN.\n * - Boolean types get turned into numbers, which probably will be meaningless\n *   to whatever is consuming them.\n * - It tries to interpolate between identical start and end values, doing\n *   unnecessary calculations that sometimes result in floating point rounding\n *   errors.\n *\n * If only the default interpolators are used, `VictoryAnimation` will happily\n * pass down NaN (and other bad) values as props to the wrapped component.\n * The component will then either use the incorrect values or complain that it\n * was passed props of the incorrect type. This custom interpolator is added\n * using the `d3.interpolators` API, and prevents such cases from happening\n * for most values.\n *\n * @param {any} a - Start value.\n * @param {any} b - End value.\n * @returns {Function|undefined} An interpolation function, if necessary.\n */\nexport const victoryInterpolator = function (a, b) {\n  // If the values are strictly equal, or either value is not interpolatable,\n  // just use either the start value `a` or end value `b` at every step, as\n  // there is no reasonable in-between value.\n  if (a === b || !isInterpolatable(a) || !isInterpolatable(b)) {\n    return interpolateImmediate(a, b);\n  }\n  if (typeof a === \"function\" || typeof b === \"function\") {\n    return interpolateFunction(a, b);\n  }\n  if (_isPlainObject(a) || _isPlainObject(b)) {\n    // @ts-expect-error These generics are tough, but they work :)\n    return interpolateObject(a, b);\n  }\n  if (typeof a === \"string\" || typeof b === \"string\") {\n    return interpolateString(a, b);\n  }\n  // @ts-expect-error These generics are tough, but they work :)\n  return interpolate(a, b);\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}